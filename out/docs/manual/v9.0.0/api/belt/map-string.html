<!DOCTYPE html><html><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css"/><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2b269719632b344a478b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2b269719632b344a478b.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/webpack-c49b9de92a7202ac2146.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework-23118dcc1b886e5b49be.js" as="script"/><link rel="preload" href="/_next/static/chunks/main-82e7c4d3c08582bd58e0.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-9e9d9ab67b4ceb7ec93b.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/docs/manual/v9.0.0/api/belt/map-string-d222590c5a64a16cd400.js" as="script"/></head><body><div id="__next"><h1 id="mapstring">MapString</h1><div><p>Specalized when key type is <code>string</code>, more efficient than the generic type, its compare behavior is fixed using the built-in comparison</p></div><h2 id="key">key</h2><pre><code class="language-res" metastring="prelude">type key = string
</code></pre><h2 id="t">t</h2><pre><code class="language-res" metastring="prelude">type t&lt;&#x27;value&gt;
</code></pre><p>The type of maps from type <code>key</code> to type <code>&#x27;value</code>.</p><h2 id="empty">empty</h2><pre><code class="language-res" metastring="sig">let empty: t&lt;&#x27;v&gt;
</code></pre><h2 id="isempty">isEmpty</h2><pre><code class="language-res" metastring="sig">let isEmpty: t&lt;&#x27;v&gt; =&gt; bool
</code></pre><h2 id="has">has</h2><pre><code class="language-res" metastring="sig">let has: (t&lt;&#x27;v&gt;, key) =&gt; bool
</code></pre><h2 id="cmpu">cmpU</h2><pre><code class="language-res" metastring="sig">let cmpU: (t&lt;&#x27;v&gt;, t&lt;&#x27;v&gt;, (. &#x27;v, &#x27;v) =&gt; int) =&gt; int
</code></pre><h2 id="cmp">cmp</h2><pre><code class="language-res" metastring="sig">let cmp: (t&lt;&#x27;v&gt;, t&lt;&#x27;v&gt;, (&#x27;v, &#x27;v) =&gt; int) =&gt; int
</code></pre><h2 id="equ">eqU</h2><pre><code class="language-res" metastring="sig">let eqU: (t&lt;&#x27;v&gt;, t&lt;&#x27;v&gt;, (. &#x27;v, &#x27;v) =&gt; bool) =&gt; bool
</code></pre><h2 id="eq">eq</h2><pre><code class="language-res" metastring="sig">let eq: (t&lt;&#x27;v&gt;, t&lt;&#x27;v&gt;, (&#x27;v, &#x27;v) =&gt; bool) =&gt; bool
</code></pre><p><code>eq(m1, m2)</code> tests whether the maps <code>m1</code> and <code>m2</code> are equal, that is, contain equal keys and associate them with equal data.</p><h2 id="findfirstbyu">findFirstByU</h2><pre><code class="language-res" metastring="sig">let findFirstByU: (t&lt;&#x27;v&gt;, (. key, &#x27;v) =&gt; bool) =&gt; option&lt;(key, &#x27;v)&gt;
</code></pre><h2 id="findfirstby">findFirstBy</h2><pre><code class="language-res" metastring="sig">let findFirstBy: (t&lt;&#x27;v&gt;, (key, &#x27;v) =&gt; bool) =&gt; option&lt;(key, &#x27;v)&gt;
</code></pre><p><code>findFirstBy(m, p)</code> uses function <code>f</code> to find the first key value pair to match predicate <code>p</code>.</p><pre><code class="language-res" metastring="example">let s0 = Belt.Map.String.fromArray([(&quot;4&quot;, 4), (&quot;1&quot;, 1), (&quot;2&quot;, 2), (&quot;3&quot;, 3)])

Belt.Map.String.findFirstBy(s0, (k, _) =&gt; k == &quot;4&quot;) == Some((&quot;4&quot;, 4))
</code></pre><h2 id="foreachu">forEachU</h2><pre><code class="language-res" metastring="sig">let forEachU: (t&lt;&#x27;v&gt;, (. key, &#x27;v) =&gt; unit) =&gt; unit
</code></pre><h2 id="foreach">forEach</h2><pre><code class="language-res" metastring="sig">let forEach: (t&lt;&#x27;v&gt;, (key, &#x27;v) =&gt; unit) =&gt; unit
</code></pre><p><code>forEach(m, f)</code> applies <code>f</code> to all bindings in map <code>m</code>. <code>f</code> receives the key as first argument, and the associated value as second argument. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p><h2 id="reduceu">reduceU</h2><pre><code class="language-res" metastring="sig">let reduceU: (t&lt;&#x27;v&gt;, &#x27;v2, (. &#x27;v2, key, &#x27;v) =&gt; &#x27;v2) =&gt; &#x27;v2
</code></pre><h2 id="reduce">reduce</h2><pre><code class="language-res" metastring="sig">let reduce: (t&lt;&#x27;v&gt;, &#x27;v2, (&#x27;v2, key, &#x27;v) =&gt; &#x27;v2) =&gt; &#x27;v2
</code></pre><p><code>reduce(m, a, f)</code> computes <code>f(kN, dN ... f(k1, d1, a)...), where k1 ... kN)</code> are the keys of all bindings in <code>m</code> (in increasing order), and <code>d1 ... dN</code> are the associated data.</p><h2 id="everyu">everyU</h2><pre><code class="language-res" metastring="sig">let everyU: (t&lt;&#x27;v&gt;, (. key, &#x27;v) =&gt; bool) =&gt; bool
</code></pre><h2 id="every">every</h2><pre><code class="language-res" metastring="sig">let every: (t&lt;&#x27;v&gt;, (key, &#x27;v) =&gt; bool) =&gt; bool
</code></pre><p><code>every(m, p)</code> checks if all the bindings of the map satisfy the predicate <code>p</code>. Order unspecified</p><h2 id="someu">someU</h2><pre><code class="language-res" metastring="sig">let someU: (t&lt;&#x27;v&gt;, (. key, &#x27;v) =&gt; bool) =&gt; bool
</code></pre><h2 id="some">some</h2><pre><code class="language-res" metastring="sig">let some: (t&lt;&#x27;v&gt;, (key, &#x27;v) =&gt; bool) =&gt; bool
</code></pre><p><code>some(m, p)</code> checks if at least one binding of the map satisfy the predicate <code>p</code>. Order unspecified</p><h2 id="size">size</h2><pre><code class="language-res" metastring="sig">let size: t&lt;&#x27;v&gt; =&gt; int
</code></pre><h2 id="tolist">toList</h2><pre><code class="language-res" metastring="sig">let toList: t&lt;&#x27;v&gt; =&gt; list&lt;(key, &#x27;v)&gt;
</code></pre><p>In increasing order.</p><h2 id="toarray">toArray</h2><pre><code class="language-res" metastring="sig">let toArray: t&lt;&#x27;v&gt; =&gt; array&lt;(key, &#x27;v)&gt;
</code></pre><h2 id="fromarray">fromArray</h2><pre><code class="language-res" metastring="sig">let fromArray: array&lt;(key, &#x27;v)&gt; =&gt; t&lt;&#x27;v&gt;
</code></pre><h2 id="keystoarray">keysToArray</h2><pre><code class="language-res" metastring="sig">let keysToArray: t&lt;&#x27;v&gt; =&gt; array&lt;key&gt;
</code></pre><h2 id="valuestoarray">valuesToArray</h2><pre><code class="language-res" metastring="sig">let valuesToArray: t&lt;&#x27;v&gt; =&gt; array&lt;&#x27;v&gt;
</code></pre><h2 id="minkey">minKey</h2><pre><code class="language-res" metastring="sig">let minKey: t&lt;&#x27;a&gt; =&gt; option&lt;key&gt;
</code></pre><h2 id="minkeyundefined">minKeyUndefined</h2><pre><code class="language-res" metastring="sig">let minKeyUndefined: t&lt;&#x27;a&gt; =&gt; Js.undefined&lt;key&gt;
</code></pre><h2 id="maxkey">maxKey</h2><pre><code class="language-res" metastring="sig">let maxKey: t&lt;&#x27;a&gt; =&gt; option&lt;key&gt;
</code></pre><h2 id="maxkeyundefined">maxKeyUndefined</h2><pre><code class="language-res" metastring="sig">let maxKeyUndefined: t&lt;&#x27;a&gt; =&gt; Js.undefined&lt;key&gt;
</code></pre><h2 id="minimum">minimum</h2><pre><code class="language-res" metastring="sig">let minimum: t&lt;&#x27;v&gt; =&gt; option&lt;(key, &#x27;v)&gt;
</code></pre><h2 id="minundefined">minUndefined</h2><pre><code class="language-res" metastring="sig">let minUndefined: t&lt;&#x27;v&gt; =&gt; Js.undefined&lt;(key, &#x27;v)&gt;
</code></pre><h2 id="maximum">maximum</h2><pre><code class="language-res" metastring="sig">let maximum: t&lt;&#x27;v&gt; =&gt; option&lt;(key, &#x27;v)&gt;
</code></pre><h2 id="maxundefined">maxUndefined</h2><pre><code class="language-res" metastring="sig">let maxUndefined: t&lt;&#x27;v&gt; =&gt; Js.undefined&lt;(key, &#x27;v)&gt;
</code></pre><h2 id="get">get</h2><pre><code class="language-res" metastring="sig">let get: (t&lt;&#x27;v&gt;, key) =&gt; option&lt;&#x27;v&gt;
</code></pre><h2 id="getundefined">getUndefined</h2><pre><code class="language-res" metastring="sig">let getUndefined: (t&lt;&#x27;v&gt;, key) =&gt; Js.undefined&lt;&#x27;v&gt;
</code></pre><h2 id="getwithdefault">getWithDefault</h2><pre><code class="language-res" metastring="sig">let getWithDefault: (t&lt;&#x27;v&gt;, key, &#x27;v) =&gt; &#x27;v
</code></pre><h2 id="getexn">getExn</h2><pre><code class="language-res" metastring="sig">let getExn: (t&lt;&#x27;v&gt;, key) =&gt; &#x27;v
</code></pre><h2 id="checkinvariantinternal">checkInvariantInternal</h2><pre><code class="language-res" metastring="sig">let checkInvariantInternal: t&lt;&#x27;a&gt; =&gt; unit
</code></pre><p><strong>raise</strong> when invariant is not held</p><h2 id="remove">remove</h2><pre><code class="language-res" metastring="sig">let remove: (t&lt;&#x27;v&gt;, key) =&gt; t&lt;&#x27;v&gt;
</code></pre><p><code>remove(m, x)</code> returns a map containing the same bindings as <code>m</code>, except for <code>x</code> which is unbound in the returned map.</p><h2 id="removemany">removeMany</h2><pre><code class="language-res" metastring="sig">let removeMany: (t&lt;&#x27;v&gt;, array&lt;key&gt;) =&gt; t&lt;&#x27;v&gt;
</code></pre><h2 id="set">set</h2><pre><code class="language-res" metastring="sig">let set: (t&lt;&#x27;v&gt;, key, &#x27;v) =&gt; t&lt;&#x27;v&gt;
</code></pre><p><code>set(m, x, y)</code> returns a map containing the same bindings as <code>m</code>, plus a binding of <code>x</code> to <code>y</code>. If <code>x</code> was already bound in <code>m</code>, its previous binding disappears.</p><h2 id="updateu">updateU</h2><pre><code class="language-res" metastring="sig">let updateU: (t&lt;&#x27;v&gt;, key, (. option&lt;&#x27;v&gt;) =&gt; option&lt;&#x27;v&gt;) =&gt; t&lt;&#x27;v&gt;
</code></pre><h2 id="update">update</h2><pre><code class="language-res" metastring="sig">let update: (t&lt;&#x27;v&gt;, key, option&lt;&#x27;v&gt; =&gt; option&lt;&#x27;v&gt;) =&gt; t&lt;&#x27;v&gt;
</code></pre><h2 id="mergeu">mergeU</h2><pre><code class="language-res" metastring="sig">let mergeU: (t&lt;&#x27;v&gt;, t&lt;&#x27;v2&gt;, (. key, option&lt;&#x27;v&gt;, option&lt;&#x27;v2&gt;) =&gt; option&lt;&#x27;c&gt;) =&gt; t&lt;&#x27;c&gt;
</code></pre><h2 id="merge">merge</h2><pre><code class="language-res" metastring="sig">let merge: (t&lt;&#x27;v&gt;, t&lt;&#x27;v2&gt;, (key, option&lt;&#x27;v&gt;, option&lt;&#x27;v2&gt;) =&gt; option&lt;&#x27;c&gt;) =&gt; t&lt;&#x27;c&gt;
</code></pre><p><code>merge(m1, m2, f)</code> computes a map whose keys is a subset of keys of <code>m1</code> and of <code>m2</code>. The presence of each such binding, and the corresponding value, is determined with the function <code>f</code>.</p><h2 id="mergemany">mergeMany</h2><pre><code class="language-res" metastring="sig">let mergeMany: (t&lt;&#x27;v&gt;, array&lt;(key, &#x27;v)&gt;) =&gt; t&lt;&#x27;v&gt;
</code></pre><h2 id="keepu">keepU</h2><pre><code class="language-res" metastring="sig">let keepU: (t&lt;&#x27;v&gt;, (. key, &#x27;v) =&gt; bool) =&gt; t&lt;&#x27;v&gt;
</code></pre><h2 id="keep">keep</h2><pre><code class="language-res" metastring="sig">let keep: (t&lt;&#x27;v&gt;, (key, &#x27;v) =&gt; bool) =&gt; t&lt;&#x27;v&gt;
</code></pre><p><code>keep(m, p)</code> returns the map with all the bindings in <code>m</code> that satisfy predicate <code>p</code>.</p><h2 id="partitionu">partitionU</h2><pre><code class="language-res" metastring="sig">let partitionU: (t&lt;&#x27;v&gt;, (. key, &#x27;v) =&gt; bool) =&gt; (t&lt;&#x27;v&gt;, t&lt;&#x27;v&gt;)
</code></pre><h2 id="partition">partition</h2><pre><code class="language-res" metastring="sig">let partition: (t&lt;&#x27;v&gt;, (key, &#x27;v) =&gt; bool) =&gt; (t&lt;&#x27;v&gt;, t&lt;&#x27;v&gt;)
</code></pre><p><code>partition(m, p)</code> returns a pair of maps <code>(m1, m2)</code>, where <code>m1</code> contains all the bindings of <code>s</code> that satisfy the predicate <code>p</code>, and <code>m2</code> is the map with all the bindings of s that do not satisfy <code>p</code>.</p><h2 id="split">split</h2><pre><code class="language-res" metastring="sig">let split: (key, t&lt;&#x27;v&gt;) =&gt; (t&lt;&#x27;v&gt;, option&lt;&#x27;v&gt;, t&lt;&#x27;v&gt;)
</code></pre><p><code>split(x, m)</code> returns a triple <code>(l, data, r)</code>, where <code>l</code> is the map with all the bindings of <code>m</code> whose key is strictly less than <code>x</code>; <code>r</code> is the map with all the bindings of m whose key is strictly greater than <code>x</code>; <code>data</code> is <code>None</code> if <code>m</code> contains no binding for <code>x</code>, or <code>Some(v)</code> if <code>m</code> binds <code>v</code> to <code>x</code>.</p><h2 id="mapu">mapU</h2><pre><code class="language-res" metastring="sig">let mapU: (t&lt;&#x27;v&gt;, (. &#x27;v) =&gt; &#x27;v2) =&gt; t&lt;&#x27;v2&gt;
</code></pre><h2 id="map">map</h2><pre><code class="language-res" metastring="sig">let map: (t&lt;&#x27;v&gt;, &#x27;v =&gt; &#x27;v2) =&gt; t&lt;&#x27;v2&gt;
</code></pre><p><code>map(m, f)</code> returns a map with same domain as <code>m</code>, where the associated value <code>a</code> of all bindings of <code>m</code> has been replaced by the result of the application of <code>f</code> to <code>a</code>. The bindings are passed to <code>f</code> in increasing order with respect to the ordering over the type of the keys.</p><h2 id="mapwithkeyu">mapWithKeyU</h2><pre><code class="language-res" metastring="sig">let mapWithKeyU: (t&lt;&#x27;v&gt;, (. key, &#x27;v) =&gt; &#x27;v2) =&gt; t&lt;&#x27;v2&gt;
</code></pre><h2 id="mapwithkey">mapWithKey</h2><pre><code class="language-res" metastring="sig">let mapWithKey: (t&lt;&#x27;v&gt;, (key, &#x27;v) =&gt; &#x27;v2) =&gt; t&lt;&#x27;v2&gt;
</code></pre></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/docs/manual/v9.0.0/api/belt/map-string","query":{},"buildId":"MNWhb0iJMu03bzcPsozl5","runtimeConfig":{},"nextExport":true,"autoExport":true,"isFallback":false}</script><script nomodule="" src="/_next/static/chunks/polyfills-9def993fe817cc057038.js"></script><script src="/_next/static/chunks/webpack-c49b9de92a7202ac2146.js" async=""></script><script src="/_next/static/chunks/framework-23118dcc1b886e5b49be.js" async=""></script><script src="/_next/static/chunks/main-82e7c4d3c08582bd58e0.js" async=""></script><script src="/_next/static/chunks/pages/_app-9e9d9ab67b4ceb7ec93b.js" async=""></script><script src="/_next/static/chunks/pages/docs/manual/v9.0.0/api/belt/map-string-d222590c5a64a16cd400.js" async=""></script><script src="/_next/static/MNWhb0iJMu03bzcPsozl5/_buildManifest.js" async=""></script><script src="/_next/static/MNWhb0iJMu03bzcPsozl5/_ssgManifest.js" async=""></script><script async="" defer="" src="https://scripts.simpleanalyticscdn.com/latest.js"></script><noscript><img src="https://queue.simpleanalyticscdn.com/noscript.gif" alt=""/></noscript></body></html>
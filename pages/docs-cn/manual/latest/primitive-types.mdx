---
title: "åŸºç¡€ç±»å‹"
description: "Primitive Data Types in ReScript"
canonical: "/docs/manual/latest/primitive-types"
---

<!-- # Primitive Types -->
# åŸºç¡€ç±»å‹

<!-- ReScript comes with the familiar primitive types like `string`, `int`, `float`, etc. -->

ReScript è‡ªå¸¦æˆ‘ä»¬æ‰€ç†Ÿæ‚‰çš„åŸºç¡€ç±»å‹ï¼Œæ¯”å¦‚ `string`ï¼Œ`int`ï¼Œ`float` ç­‰ã€‚

<!-- TODO: doc unit -->

<!-- ## String -->
## å­—ç¬¦ä¸²

<!-- ReScript `string`s are delimited using **double** quotes (single quotes are reserved for the character type below). -->

åœ¨ ReScript é‡Œå­—ç¬¦ä¸²å†™åœ¨åŒå¼•å·ä¸­ï¼ˆå•å¼•å·è¢«ä¿ç•™ç”¨æ¥è¡¨ç¤ºå­—ç¬¦ç±»å‹ï¼‰ã€‚

<CodeTab labels={["ReScript", "JS Output"]}>

```res example
let greeting = "Hello world!"
let multilineGreeting = "Hello
 world!"
```
```js
var greeting = "Hello world!";
var multilineGreeting = "Hello\n world!";
```

</CodeTab>

<!-- To concatenate strings, use `++`: -->

è¦è¿æ¥ä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œä½¿ç”¨`++`è¿ç®—ç¬¦ï¼š

<CodeTab labels={["ReScript", "JS Output"]}>

```res example
let greetings = "Hello " ++ "world!"
```
```js
var greetings = "Hello world!";
```

</CodeTab>

<!-- ### String Interpolation -->
### å­—ç¬¦ä¸²æ’å€¼

<!-- There's a special syntax for string that allows -->

æœ‰ä¸€ä¸ªç‰¹æ®Šçš„å­—ç¬¦ä¸²è¯­æ³•ï¼Œå®ƒå…è®¸ï¼š

<!--
- multiline string just like before
- no special character escaping
- Interpolation
- Proper unicode handling
-->

- å¤šè¡Œå­—ç¬¦ä¸²
- æ²¡æœ‰ç‰¹æ®Šçš„è½¬ä¹‰å­—ç¬¦
- æ’å€¼
- æ›´å¥½çš„ unicode å¤„ç†

<CodeTab labels={["ReScript", "JS Output"]}>

```res example
let name = "Joe"

let greeting = `Hello
World
ğŸ‘‹
${name}
`
```
```js
var name = "Joe";

var greeting = "Hello\nWorld\nğŸ‘‹\n" + name + "\n";
```

</CodeTab>

<!-- This is just like JavaScript's backtick string interpolation, except without needing to escape special characters. -->

è¿™å°±åƒJavaScriptçš„åå¼•å·å­—ç¬¦ä¸²æ’å€¼ï¼Œåªæ˜¯ä¸éœ€è¦è½¬ä¹‰ç‰¹æ®Šå­—ç¬¦ã€‚ 

<!-- For interpolation, you'll have to convert the binding (`name` in the example) into a string if it isn't one. If you want the interpolation to implicitly convert a binding into a string, prepend a `j`: -->

å¯¹äºå­—ç¬¦ä¸²æ’å€¼ï¼Œå¦‚æœç»‘å®šçš„å€¼ä¸æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²(æ¯”å¦‚ä¸Šè¿°ä¾‹å­ä¸­çš„ `name`)ï¼Œä½ å°±å¿…é¡»å°†å…¶è½¬æ¢æˆå­—ç¬¦ä¸²ã€‚ å¦‚æœä½ éœ€è¦éšå¼çš„è½¬æ¢ä¸€ä¸ªç»‘å®šåˆ°å­—ç¬¦ä¸²ï¼Œå¯ä»¥åœ¨å­—ç¬¦ä¸²å‰åŠ ä¸€ä¸ª `j`

<CodeTab labels={["ReScript", "JS Output"]}>

```res example
let age = 10
let message = j`Today I am $age years old.`
```
```js
var message = "Today I am " + 10 + " years old.";
```

</CodeTab>

### ç”¨æ³•

<!-- See the familiar `Js.String` API in the [API docs](api/js/string). Since a ReScript string maps to a JavaScript string, you can mix & match the string operations in both standard libraries. -->

åœ¨[APIæ–‡æ¡£](api/js/string)ä¸­æŸ¥çœ‹æˆ‘ä»¬ç†Ÿæ‚‰çš„ `Js.String` APIã€‚ å› ä¸ºä¸€ä¸ªReScriptå­—ç¬¦æ˜ å°„å­—ç¬¦ä¸²åˆ°JavaScriptå­—ç¬¦ä¸²ï¼Œä½ å¯ä»¥æ··ç”¨æˆ–æ¯”è¾ƒä¸¤ä¸ªæ ‡å‡†åº“ä¸­çš„å­—ç¬¦ä¸²ã€‚

### æŠ€å·§ & è¯€çª

<!-- **You have a good type system now**! In an untyped language, you'd often overload the meaning of string by using it as: -->

**ä½ ç°åœ¨æœ‰äº†ä¸€ä¸ªå¥½çš„ç±»å‹ç³»ç»Ÿäº†**ï¼åœ¨éé™æ€ç±»å‹è¯­è¨€ä¸­ï¼Œä½ å¯èƒ½ç»å¸¸éœ€è¦é‡è½½å­—ç¬¦ä¸²çš„æ„ä¹‰ï¼Œæ¯”å¦‚è¯´:

<!-- - a unique id: `var BLUE_COLOR = "blue"`
- an identifier into a data structure: `var BLUE = "blue" var RED = "red" var colors = [BLUE, RED]`
- the name of an object field: `person["age"] = 24`
- an enum: `if (audio.canPlayType() === 'probably') {...}` [(à² _à² )](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canPlayType#Return_value)
- other crazy patterns you'll soon find horrible, after getting used to ReScript's alternatives. -->

- ä¸€ä¸ªå•ç‹¬çš„id: `var BLUE_COLOR = "blue"`
- å°†æ ‡è¯†ç¬¦æ”¾å…¥ä¸€ä¸ªæ•°æ®ç»“æ„ä¸­: `var BLUE = "blue" var RED = "red" var colors = [BLUE, RED]`
- å¯¹è±¡çš„å±æ€§: `person["age"] = 24`
- ä½œä¸ºæšä¸¾ä½¿ç”¨: `if (audio.canPlayType() === 'probably') {...}` [(à² _à² )](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canPlayType#Return_value)
- åœ¨ä¹ æƒ¯äº†ReScriptä½œä¸ºæ›¿ä»£å“ä¹‹åï¼Œä½ å¾ˆå¿«å°±ä¼šå‘ç°ï¼Œå…¶ä»–ç–¯ç‹‚çš„æ¨¡å¼æ˜¯å¤šä¹ˆå¯æ€•ã€‚

<!-- The more you overload the poor string type, the less the type system (or a teammate) can help you! ReScript provides concise, fast and maintainable types & data structures alternatives to the use-cases above (e.g. variants, in a later section). -->

ä½ å¯¹å¯æ€œçš„å­—ç¬¦ä¸²ç±»å‹çš„æ„ä¹‰é‡è½½æ¬¡æ•°è¶Šå¤šï¼Œç±»å‹ç³»ç»Ÿ(æˆ–ç§°ä¹‹ä¸ºä½ çš„é˜Ÿå‹)èƒ½å¤Ÿå¸®åŠ©ä½ çš„ç¨‹åº¦å°±è¶Šä½! ReScript ä¸ºä¸Šè¿°ä½¿ç”¨æƒ…å†µçš„ç±»å‹å’Œæ•°æ®ç»“æ„çš„æ›¿ä»£æ–¹æ¡ˆ (ä¾‹å¦‚ï¼Œå˜ä½“ï¼Œåœ¨åé¢çš„ç« èŠ‚) ï¼ŒReScriptçš„æ–¹æ¡ˆæ˜¯ç®€æ´ï¼Œå¿«é€Ÿå’Œå¯ç»´æŠ¤çš„ã€‚ 

## å­—ç¬¦

<!-- ReScript has a type for a string with a single letter: -->

ReScripté€‚ç”¨äºå•å­—æ¯çš„å­—ç¬¦ä¸²çš„ç±»å‹ã€‚

<CodeTab labels={["ReScript", "JS Output"]}>

```res example
let firstLetterOfAlphabet = 'a'
```
```js
var firstLetterOfAlphabet = /* "a" */97;
```

</CodeTab>

<!-- **Note**: Char doesn't support Unicode or UTF-8 and is therefore not recommended. -->

**æ³¨æ„**: Charä¸æ”¯æŒUnicodeæˆ–UTF-8ï¼Œå› æ­¤ä¸æ¨èä½¿ç”¨

<!-- To convert a String to a Char, use `String.get("a", 0)`. To convert a Char to a String, use `String.make(1, 'a')`. -->

å¯ä»¥é€šè¿‡ `String.get("a", 0)` è½¬æ¢ä¸€ä¸ªå­—ç¬¦ä¸²åˆ°å­—ç¬¦ï¼Œé€šè¿‡`String.make(1, 'a')`è½¬æ¢ä¸€ä¸ªå­—ç¬¦åˆ°å­—ç¬¦ä¸²ã€‚

<!-- Regular Expression -->
## æ­£åˆ™è¡¨è¾¾å¼

<!-- ReScript regular expressions compile cleanly to their JavaScript counterpart: -->

ReScriptçš„æ­£åˆ™è¡¨è¾¾å¼ä¼šç®€æ´çš„ç¼–è¯‘åˆ°JavaScriptçš„å¯¹ç­‰ç‰©ã€‚

<CodeTab labels={["ReScript", "JS Output"]}>

```res example
let r = %re("/b/g")
```
```js
var r = /b/g;
```

</CodeTab>

<!-- A regular expression like the above has the type `Js.Re.t`. The [Js.Re](api/js/re) module contains the regular expression helpers you have seen in JS. -->

ä¸€ä¸ªåƒä¸Šé¢ä¸€æ ·çš„æ­£åˆ™è¡¨è¾¾å¼çš„ç±»å‹æ˜¯ `Js.Re.t`. [Js.Re](api/js/re)æ¨¡å—åŒ…æ‹¬ä¸€äº›æ­£åˆ™è¡¨è¾¾å¼çš„è¾…åŠ©å‡½æ•°ï¼Œä½ åº”è¯¥å·²ç»åœ¨JSä¸­è§è¿‡å®ƒä»¬ã€‚

## å¸ƒå°”ç±»å‹

<!-- A ReScript boolean has the type `bool` and can be either `true` or `false`. Common operations: -->

ReScriptçš„å¸ƒå°”å€¼çš„ç±»å‹æ˜¯`bool`ï¼Œå¯ä»¥æ˜¯`true`æˆ–`false`ã€‚ ä¸€ä¸‹æ˜¯ä¸€äº›å¸¸è§çš„ä¸å¸ƒå°”å€¼æœ‰å…³çš„æ“ä½œ:

<!-- - `&&`: logical and.
- `||`: logical or.
- `!`: logical not.
- `<=`, `>=`, `<`, `>`
- `==`: structural equal, compares data structures deeply: `(1, 2) == (1, 2)` is `true`. Convenient, but use with caution.
- `===`: referential equal, compares shallowly. `(1, 2) === (1, 2)` is `false`. `let myTuple = (1, 2); myTuple === myTuple` is `true`.
- `!=`: structural unequal.
- `!==`: referential unequal. -->

- `&&`: é€»è¾‘ä¸ã€‚
- `||`: é€»è¾‘æˆ–ã€‚
- `!`: é€»è¾‘éã€‚
- `<=`, `>=`ï¼Œ`<`, `>`
- `==`: ç»“æ„åŒ–ç›¸ç­‰ï¼Œæ·±å…¥çš„æ¯”è¾ƒæ•°æ®ç»“æ„: `(1, 2) == (1, 2)` ç­‰äº `true`ã€‚ å¾ˆæ–¹ä¾¿, ä½†ç”¨çš„æ—¶å€™éœ€è¦æ³¨æ„
- `===`: å¼•ç”¨ç›¸ç­‰, æµ…å±‚çš„æ¯”è¾ƒæ•°æ®ç»“æ„ã€‚ `(1, 2) === (1, 2)` ç­‰äº `false`ã€‚ `let myTuple = (1, 2); myTuple === myTuple` is `true`ã€‚
- `!=`: ç»“æ„åŒ–ä¸ç›¸ç­‰ã€‚
- `!==`: å¼•ç”¨ç›¸ç­‰ã€‚

ReScriptçš„ `true/false` ç¼–è¯‘åˆ° JavaScript `true/false`ã€‚

/* ## Integers */
## æ•´æ•°

<!-- 32-bits, truncated when necessary. We provide the usual operations on them: `+`, `-`, `*`, `/`, etc. See [Js.Int](api/js/int) for helper functions. -->

32ä½æ•´æ•°ï¼Œå¯èƒ½åœ¨éœ€è¦çš„æ—¶å€™è¢«è£å‰ªã€‚ æˆ‘ä»¬ä¸ºå®ƒä»¬æä¾›å¸¸ç”¨çš„æ“ä½œ: `+`ï¼Œ`-`ï¼Œ`*`ï¼Œ`/`... ã€‚ [Js.Int](api/js/int)æ¨¡å—åŒ…å«ä¸€äº›æ•´æ•°çš„è¾…åŠ©å‡½æ•°ã€‚

/* **Be careful when you bind to JavaScript numbers!** Since ReScript integers have a much smaller range than JavaScript numbers, data might get lost when dealing with large numbers. In those cases itâ€™s much safer to bind the numbers as **float**. Be extra mindful of this when binding to JavaScript Dates and their epoch time.  */

**å½“ç»‘å®šåˆ°JavaScriptæ•°å­—æ—¶è¦å°å¿ƒï¼** ç”±äºReScriptæ•´æ•°çš„èŒƒå›´æ¯”JavaScriptæ•°å­—å°å¾—å¤šï¼Œåœ¨å¤„ç†å¤§æ•°å­—æ—¶ï¼Œæ•°æ®å¯èƒ½ä¼šä¸¢å¤±ã€‚ åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå°†æ•°å­—ç»‘å®šä¸º**float**è¦å®‰å…¨å¾—å¤šã€‚ å½“ç»‘å®šåˆ°JavaScriptæ—¥æœŸå’Œå®ƒä»¬çš„epoch timeæ—¶è¦ç‰¹åˆ«æ³¨æ„è¿™ä¸€ç‚¹ã€‚

/* To improve readability, you may place underscores in the middle of numeric literals such as `1_000_000`. Note that underscores can be placed anywhere within a number, not just every three digits.  */

ä¸ºäº†æé«˜å¯è¯»æ€§ï¼Œä½ å¯ä»¥å°†ä¸‹åˆ’çº¿æ”¾åœ¨æ•°å­—çš„ä¸­é—´ï¼Œå¦‚`1_000_000`ã€‚ æ³¨æ„ï¼Œä¸‹åˆ’çº¿å¯ä»¥æ”¾åœ¨æ•°å­—çš„ä»»ä½•åœ°æ–¹ï¼Œè€Œä¸æ˜¯åªæœ‰æ¯ä¸‰ä½æ•°å­—éƒ½æ‰å¯ä»¥ã€‚

/* ## Floats */
## æµ®ç‚¹æ•°

/* Float requires other operators: `+.`, `-.`, `*.`, `/.`, etc. Like `0.5 +. 0.6`. See [Js.Float](api/js/float) for helper functions. */

æµ®ç‚¹æ•°çš„è¿ç®—éœ€è¦å…¶ä»–è¿ç®—ç¬¦ï¼š `+.`ï¼Œ`-.`ï¼Œ`*.`ï¼Œ`/.` ... ï¼Œå¦‚`0.5 +. 0.6`ã€‚ å‚è§[Js.Float](api/js/float)æ¨¡å—ä¸­çš„è¾…åŠ©å‡½æ•°ã€‚ 

<!-- As with integers, you may use underscores within literals to improve readability. -->

å’Œæ•´æ•°ä¸€æ ·ï¼Œä½ å¯ä»¥åœ¨å­—é¢å€¼ä¸Šä½¿ç”¨ä¸‹åˆ’çº¿ä»¥æé«˜å¯è¯»æ€§ã€‚

/* ## Unit */
## unit ç±»å‹

/* The `unit` type has a single value, `()`. It compiles to JavaScript's `undefined`. It's a dummy type used as a placeholder in various places. You won't need it until you see it.  */
`unit`ç±»å‹åªæœ‰ä¸€ä¸ªå€¼ï¼Œå³ `()`ã€‚ å®ƒå¯ä»¥ç¼–è¯‘ä¸º JavaScript çš„ `undefined'ã€‚ å®ƒæ˜¯ä¸€ä¸ªå“‘ï¼ˆdummyï¼‰ç±»å‹ï¼Œå¸¸åœ¨ä¸åŒçš„åœ°æ–¹ä½œä¸ºå ä½ç¬¦ä½¿ç”¨ã€‚ ä½ åªæœ‰åœ¨çœ‹åˆ°å®ƒçš„æ—¶å€™æ‰ä¼šéœ€è¦ç”¨åˆ°å®ƒã€‚

(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[11695],{17375:function(e,n,t){"use strict";function a(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}t.d(n,{Z:function(){return a}})},51929:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return u}});var a=t(17375),o=t(96156),r=(t(67294),t(3905));function p(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?p(Object(t),!0).forEach((function(n){(0,o.Z)(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):p(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}var l,s=(l="Intro",function(e){return console.warn("Component "+l+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",i({},e))}),m={};function u(e){var n=e.components,t=(0,a.Z)(e,["components"]);return(0,r.kt)("wrapper",i(i(i({},m),t),{},{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",i({},{id:"option"}),"Option"),(0,r.kt)(s,{mdxType:"Intro"},(0,r.kt)("p",null,"In Belt we represent the existence and nonexistence of a value by wrapping it\nwith the ",(0,r.kt)("inlineCode",{parentName:"p"},"option")," type.  In order to make it a bit more convenient to work with\noption-types, Belt provides utility-functions for it."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"option")," type is a part of the Reason / OCaml standard library which is defined like this:")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"type option<'a> = None | Some('a)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'let someString: option<string> = Some("hello")\n')),(0,r.kt)("h2",i({},{id:"getexn"}),"getExn"),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let getExn: option<'a> => 'a\n")),(0,r.kt)("p",null,"Raises an Error in case ",(0,r.kt)("inlineCode",{parentName:"p"},"None")," is provided. Use with care."),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"Belt.Option.getExn(Some(3)) /* 3 */\n\nBelt.Option.getExn(None) /* Raises an Error */\n")),(0,r.kt)("h2",i({},{id:"mapwithdefault"}),"mapWithDefault"),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let mapWithDefault: (option<'a>, 'b, 'a => 'b) => 'b\n")),(0,r.kt)("p",null,"If ",(0,r.kt)("inlineCode",{parentName:"p"},"optionValue")," is of ",(0,r.kt)("inlineCode",{parentName:"p"},"Some(value)"),",\nthis function returns that value applied with ",(0,r.kt)("inlineCode",{parentName:"p"},"f"),", in other words ",(0,r.kt)("inlineCode",{parentName:"p"},"f(value)"),"."),(0,r.kt)("p",null,"If ",(0,r.kt)("inlineCode",{parentName:"p"},"optionValue")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"None"),", the default is returned."),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"let someValue = Some(3)\nsomeValue->Belt.Option.mapWithDefault(0, x => x + 5) /* 8 */\n\nlet noneValue = None\nnoneValue->Belt.Option.mapWithDefault(0, x => x + 5) /* 0 */\n")),(0,r.kt)("h2",i({},{id:"mapwithdefaultu"}),"mapWithDefaultU"),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let mapWithDefaultU: (option<'a>, 'b, (. 'a) => 'b) => 'b\n")),(0,r.kt)("p",null,"Uncurried version of ",(0,r.kt)("a",i({parentName:"p"},{href:"#mapWithDefault"}),"mapWithDefault"),"."),(0,r.kt)("h2",i({},{id:"map"}),"map"),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let map: (option<'a>, 'a => 'b) => option<'b>\n")),(0,r.kt)("p",null,"If ",(0,r.kt)("inlineCode",{parentName:"p"},"optionValue")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"Some(value)")," this returns ",(0,r.kt)("inlineCode",{parentName:"p"},"f(value)"),", otherwise it returns ",(0,r.kt)("inlineCode",{parentName:"p"},"None"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"Belt.Option.map(Some(3), x => x * x) /* Some(9) */\n\nBelt.Option.map(None, x => x * x) /* None */\n")),(0,r.kt)("h2",i({},{id:"mapu"}),"mapU"),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let mapU: (option<'a>, (. 'a) => 'b) => option<'b>\n")),(0,r.kt)("p",null,"Uncurried version of ",(0,r.kt)("a",i({parentName:"p"},{href:"#map"}),"map"),"."),(0,r.kt)("h2",i({},{id:"flatmap"}),"flatMap"),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let flatMap: (option<'a>, 'a => option<'b>) => option<'b>\n")),(0,r.kt)("p",null,"If ",(0,r.kt)("inlineCode",{parentName:"p"},"optionValue")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"Some(value)"),", returns ",(0,r.kt)("inlineCode",{parentName:"p"},"f(value)"),", otherwise returns\n",(0,r.kt)("inlineCode",{parentName:"p"},"None"),".",(0,r.kt)("br",null),"\nThe function ",(0,r.kt)("inlineCode",{parentName:"p"},"f")," must have a return type of ",(0,r.kt)("inlineCode",{parentName:"p"},"option<'b>"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"let addIfAboveOne = value =>\n  if (value > 1) {\n    Some(value + 1)\n  } else {\n    None\n  }\n\nBelt.Option.flatMap(Some(2), addIfAboveOne) /* Some(3) */\n\nBelt.Option.flatMap(Some(-4), addIfAboveOne) /* None */\n\nBelt.Option.flatMap(None, addIfAboveOne) /* None */\n")),(0,r.kt)("h2",i({},{id:"flatmapu"}),"flatMapU"),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let flatMapU: (option<'a>, (. 'a) => option<'b>) => option<'b>\n")),(0,r.kt)("p",null,"Uncurried version of flatMap."),(0,r.kt)("h2",i({},{id:"getwithdefault"}),"getWithDefault"),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let getWithDefault: (option<'a>, 'a) => 'a\n")),(0,r.kt)("p",null,"If ",(0,r.kt)("inlineCode",{parentName:"p"},"optionalValue")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"Some(value)"),", returns ",(0,r.kt)("inlineCode",{parentName:"p"},"value"),", otherwise default."),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'Belt.Option.getWithDefault(None, "Banana") /* Banana */\n\nBelt.Option.getWithDefault(Some("Apple"), "Banana") /* Apple */\n')),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'let greet = (firstName: option<string>) =>\n  "Greetings " ++ firstName->Belt.Option.getWithDefault("Anonymous")\n\nSome("Jane")->greet /* "Greetings Jane" */\n\nNone->greet /* "Greetings Anonymous" */\n')),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"Belt.Option.getWithDefault(Some(1812), 1066) /* 1812 */\n\nBelt.Option.getWithDefault(None, 1066) /* 1066 */\n")),(0,r.kt)("h2",i({},{id:"issome"}),"isSome"),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let isSome: option<'a> => bool\n")),(0,r.kt)("p",null,"Returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the argument is ",(0,r.kt)("inlineCode",{parentName:"p"},"Some(value)"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"Belt.Option.isSome(None) /* false */\n\nBelt.Option.isSome(Some(1)) /* true */\n")),(0,r.kt)("h2",i({},{id:"isnone"}),"isNone"),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let isNone: option<'a> => bool\n")),(0,r.kt)("p",null,"Returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the argument is ",(0,r.kt)("inlineCode",{parentName:"p"},"None"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"Belt.Option.isNone(None) /* true */\n\nBelt.Option.isNone(Some(1)) /* false */\n")),(0,r.kt)("h2",i({},{id:"eq"}),"eq"),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let eq: (option<'a>, option<'b>, ('a, 'b) => bool) => bool\n")),(0,r.kt)("p",null,"Evaluates two optional values for equality with respect to a predicate\nfunction. If both ",(0,r.kt)("inlineCode",{parentName:"p"},"optValue1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"optValue2")," are ",(0,r.kt)("inlineCode",{parentName:"p"},"None"),", returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),".\nIf one of the arguments is ",(0,r.kt)("inlineCode",{parentName:"p"},"Some(value)")," and the other is ",(0,r.kt)("inlineCode",{parentName:"p"},"None"),", returns\n",(0,r.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,r.kt)("p",null,"If arguments are ",(0,r.kt)("inlineCode",{parentName:"p"},"Some(value1)")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Some(value2)"),", returns the result of\n",(0,r.kt)("inlineCode",{parentName:"p"},"predicate(value1, value2)"),"; the predicate function must return a bool."),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"let clockEqual = (a, b) => mod(a, 12) == mod(b, 12)\n\nopen Belt.Option\n\neq(Some(3), Some(15), clockEqual) /* true */\n\neq(Some(3), None, clockEqual) /* false */\n\neq(None, Some(3), clockEqual) /* false */\n\neq(None, None, clockEqual) /* true */\n")),(0,r.kt)("h2",i({},{id:"equ"}),"eqU"),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let eqU: (option<'a>, option<'b>, (.'a, 'b) => bool) => bool\n")),(0,r.kt)("p",null,"Uncurried version of ",(0,r.kt)("a",i({parentName:"p"},{href:"#eq"}),"eq"),"."),(0,r.kt)("h2",i({},{id:"cmp"}),"cmp"),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let cmp: (option<'a>, option<'b>, ('a, 'b) => int) => int\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"cmp(optValue1, optValue2, comparisonFunction)")," compares two optional values\nwith respect to given ",(0,r.kt)("inlineCode",{parentName:"p"},"comparisonFunction"),"."),(0,r.kt)("p",null,"If both ",(0,r.kt)("inlineCode",{parentName:"p"},"optValue1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"optValue2")," are ",(0,r.kt)("inlineCode",{parentName:"p"},"None"),", it returns ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),"."),(0,r.kt)("p",null,"If the first argument is ",(0,r.kt)("inlineCode",{parentName:"p"},"Some(value1)")," and the second is ",(0,r.kt)("inlineCode",{parentName:"p"},"None"),", returns ",(0,r.kt)("inlineCode",{parentName:"p"},"1"),"\n(something is greater than nothing)."),(0,r.kt)("p",null,"If the first argument is ",(0,r.kt)("inlineCode",{parentName:"p"},"None")," and the second is ",(0,r.kt)("inlineCode",{parentName:"p"},"Some(value2)"),", returns ",(0,r.kt)("inlineCode",{parentName:"p"},"-1"),"\n(nothing is less than something)."),(0,r.kt)("p",null,"If the arguments are ",(0,r.kt)("inlineCode",{parentName:"p"},"Some(value1)")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Some(value2)"),", returns the result of\n",(0,r.kt)("inlineCode",{parentName:"p"},"comparisonFunction(value1, value2)"),"; comparisonFunction takes two arguments\nand returns ",(0,r.kt)("inlineCode",{parentName:"p"},"-1")," if the first argument is less than the second, ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," if the\narguments are equal, and ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," if the first argument is greater than the second."),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"let clockCompare = (a, b) => compare(mod(a, 12), mod(b, 12))\n\nopen Belt.Option\n\ncmp(Some(3), Some(15), clockCompare) /* 0 */\n\ncmp(Some(3), Some(14), clockCompare) /* 1 */\n\ncmp(Some(2), Some(15), clockCompare) /* (-1) */\n\ncmp(None, Some(15), clockCompare) /* (-1) */\n\ncmp(Some(14), None, clockCompare) /* 1 */\n\ncmp(None, None, clockCompare) /* 0 */\n")),(0,r.kt)("h2",i({},{id:"cmpu"}),"cmpU"),(0,r.kt)("pre",null,(0,r.kt)("code",i({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let cmpU: (option<'a>, option<'b>, ((.'a, 'b) => int)) => int\n")),(0,r.kt)("p",null,"Uncurried version of ",(0,r.kt)("a",i({parentName:"p"},{href:"#cmp"}),"cmp"),"."))}u.isMDXComponent=!0,u.frontmatter={__ghEditHref:"https://github.com/rescript-idea/rescript-lang.org-chinese-translation/tree/chinese-translation/pages/docs-cn/manual/latest/api/belt/option.mdx"}},27934:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs-cn/manual/latest/api/belt/option",function(){return t(51929)}])}},function(e){e.O(0,[92888,49774,40179],(function(){return n=27934,e(e.s=n);var n}));var n=e.O();_N_E=n}]);
(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[5887],{17375:function(e,a,t){"use strict";function n(e,a){if(null==e)return{};var t,n,l=function(e,a){if(null==e)return{};var t,n,l={},s=Object.keys(e);for(n=0;n<s.length;n++)t=s[n],a.indexOf(t)>=0||(l[t]=e[t]);return l}(e,a);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)t=s[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}t.d(a,{Z:function(){return n}})},8164:function(e,a,t){"use strict";t.r(a),t.d(a,{default:function(){return h}});var n=t(17375),l=t(96156),s=(t(67294),t(3905));function r(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function p(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?r(Object(t),!0).forEach((function(a){(0,l.Z)(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}var i,u=(i="Intro",function(e){return console.warn("Component "+i+" was not imported, exported, or provided by MDXProvider as global scope"),(0,s.kt)("div",p({},e))}),m={};function h(e){var a=e.components,t=(0,n.Z)(e,["components"]);return(0,s.kt)("wrapper",p(p(p({},m),t),{},{components:a,mdxType:"MDXLayout"}),(0,s.kt)("h1",p({},{id:"hashmap"}),"HashMap"),(0,s.kt)(u,{mdxType:"Intro"},(0,s.kt)("p",null,"The top level provides generic mutable hash map operations.")),(0,s.kt)("h2",p({},{id:"t"}),"t"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"prelude",prelude:!0}),"type t<'key, 'value, 'id>\n")),(0,s.kt)("p",null,"The type of hash tables from type ",(0,s.kt)("inlineCode",{parentName:"p"},"'key")," to type ",(0,s.kt)("inlineCode",{parentName:"p"},"'value"),"."),(0,s.kt)("h2",p({},{id:"id"}),"id"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"prelude",prelude:!0}),"type id<'a, 'id> = Belt.Id.hashable<'a, 'id>\n")),(0,s.kt)("p",null,"The identity needed for making an empty hash map."),(0,s.kt)("h2",p({},{id:"make"}),"make"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let make: (~hintSize: int, ~id: id<'key, 'id>) => t<'key, 'value, 'id>\n")),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"make(~hintSize=10, ~id)")," creates a new map by taking in the comparator and ",(0,s.kt)("inlineCode",{parentName:"p"},"hintSize"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'module IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet hMap = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\n\nBelt.HashMap.set(hMap, 0, "a")\n')),(0,s.kt)("h2",p({},{id:"clear"}),"clear"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let clear: t<'key, 'value, 'id> => unit\n")),(0,s.kt)("p",null,"Clears a hash table."),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'module IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet hMap = Belt.HashMap.fromArray([(1, "1")], ~id=module(IntHash))\nBelt.HashMap.clear(hMap)\nBelt.HashMap.isEmpty(hMap) == true\n')),(0,s.kt)("h2",p({},{id:"isempty"}),"isEmpty"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let isEmpty: t<'a, 'b, 'c> => bool\n")),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"isEmpty(m)")," checks whether a hash map is empty."),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'module IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nBelt.HashMap.isEmpty(Belt.HashMap.fromArray([(1, "1")], ~id=module(IntHash))) == false\n')),(0,s.kt)("h2",p({},{id:"set"}),"set"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let set: (t<'key, 'value, 'id>, 'key, 'value) => unit\n")),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"set(hMap, k, v)")," if ",(0,s.kt)("inlineCode",{parentName:"p"},"k")," does not exist, add the binding ",(0,s.kt)("inlineCode",{parentName:"p"},"k,v"),", otherwise, update the old value with the new ",(0,s.kt)("inlineCode",{parentName:"p"},"v"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'module IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet s0 = Belt.HashMap.fromArray([(2, "2"), (1, "1"), (3, "3")], ~id=module(IntHash))\n\nBelt.HashMap.set(s0, 2, "3")\n\nBelt.HashMap.valuesToArray(s0) == ["1", "3", "3"]\n')),(0,s.kt)("h2",p({},{id:"copy"}),"copy"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let copy: t<'key, 'value, 'id> => t<'key, 'value, 'id>\n")),(0,s.kt)("p",null,"Creates copy of a hash map."),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'module IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet s0 = Belt.HashMap.fromArray([(2, "2"), (1, "1"), (3, "3")], ~id=module(IntHash))\nlet s1 = Belt.HashMap.copy(s0)\n\nBelt.HashMap.set(s0, 2, "3")\n\nBelt.HashMap.get(s0, 2) != Belt.HashMap.get(s1, 2)\n')),(0,s.kt)("h2",p({},{id:"get"}),"get"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let get: (t<'key, 'value, 'id>, 'key) => option<'value>\n")),(0,s.kt)("p",null,"Returns value bound under specific key. If values not exist returns ",(0,s.kt)("inlineCode",{parentName:"p"},"None"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'module IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\nBelt.HashMap.set(s0, 1, "value1")\n\nBelt.HashMap.get(s0, 1) == Some("value1")\nBelt.HashMap.get(s0, 2) == None\n')),(0,s.kt)("h2",p({},{id:"has"}),"has"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let has: (t<'key, 'value, 'id>, 'key) => bool\n")),(0,s.kt)("p",null,"Checks if ",(0,s.kt)("inlineCode",{parentName:"p"},"x")," is bound in ",(0,s.kt)("inlineCode",{parentName:"p"},"tbl"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'module IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\nBelt.HashMap.set(s0, 1, "value1")\n\nBelt.HashMap.has(s0, 1) == true\nBelt.HashMap.has(s0, 2) == false\n')),(0,s.kt)("h2",p({},{id:"remove"}),"remove"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let remove: (t<'key, 'value, 'id>, 'key) => unit\n")),(0,s.kt)("p",null,"If bound exists, removes it from the hash map."),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'module IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\nBelt.HashMap.set(s0, 1, "value1")\nBelt.HashMap.remove(s0, 1)\nBelt.HashMap.has(s0, 1) == false\n')),(0,s.kt)("h2",p({},{id:"foreachu"}),"forEachU"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let forEachU: (t<'key, 'value, 'id>, (. 'key, 'value) => unit) => unit\n")),(0,s.kt)("p",null,"Same as ",(0,s.kt)("a",p({parentName:"p"},{href:"##forEach"}),"forEach")," but takes uncurried functon."),(0,s.kt)("h2",p({},{id:"foreach"}),"forEach"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let forEach: (t<'key, 'value, 'id>, ('key, 'value) => unit) => unit\n")),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"forEach(tbl, f)")," applies ",(0,s.kt)("inlineCode",{parentName:"p"},"f")," to all bindings in table ",(0,s.kt)("inlineCode",{parentName:"p"},"tbl"),". ",(0,s.kt)("inlineCode",{parentName:"p"},"f")," receives the key as first argument, and the associated value as second argument. Each binding is presented exactly once to ",(0,s.kt)("inlineCode",{parentName:"p"},"f"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'module IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\nBelt.HashMap.set(s0, 1, "value1")\nBelt.HashMap.forEach(s0, (key, value) => Js.log2(key, value))\n// prints (1, "value1")\n')),(0,s.kt)("h2",p({},{id:"reduceu"}),"reduceU"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let reduceU: (t<'key, 'value, 'id>, 'c, (. 'c, 'key, 'value) => 'c) => 'c\n")),(0,s.kt)("p",null,"Same as ",(0,s.kt)("a",p({parentName:"p"},{href:"##reduce"}),"reduce")," but takes uncurried functon."),(0,s.kt)("h2",p({},{id:"reduce"}),"reduce"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let reduce: (t<'key, 'value, 'id>, 'c, ('c, 'key, 'value) => 'c) => 'c\n")),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"reduce(tbl, init, f)")," computes ",(0,s.kt)("inlineCode",{parentName:"p"},"(f(kN, dN) ... (f(k1, d1, init))...)"),", where ",(0,s.kt)("inlineCode",{parentName:"p"},"k1 ... kN")," are the keys of all bindings in ",(0,s.kt)("inlineCode",{parentName:"p"},"tbl"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"d1 ... dN")," are the associated values. Each binding is presented exactly once to ",(0,s.kt)("inlineCode",{parentName:"p"},"f"),"."),(0,s.kt)("p",null,"The order in which the bindings are passed to ",(0,s.kt)("inlineCode",{parentName:"p"},"f")," is unspecified. However, if the table contains several bindings for the same key, they are passed to ",(0,s.kt)("inlineCode",{parentName:"p"},"f")," in reverse order of introduction, that is, the most recent binding is passed first."),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'module IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\nBelt.HashMap.set(s0, 1, "value1")\nBelt.HashMap.set(s0, 2, "value2")\n\nBelt.HashMap.reduce(s0, "", (acc, key, value) => acc ++ (", " ++ value)) == "value1, value2"\n')),(0,s.kt)("h2",p({},{id:"keepmapinplaceu"}),"keepMapInPlaceU"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let keepMapInPlaceU: (t<'key, 'value, 'id>, (. 'key, 'value) => option<'value>) => unit\n")),(0,s.kt)("p",null,"Same as ",(0,s.kt)("a",p({parentName:"p"},{href:"##keepMapInPlace"}),"keepMapInPlace")," but takes uncurried functon."),(0,s.kt)("h2",p({},{id:"keepmapinplace"}),"keepMapInPlace"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let keepMapInPlace: (t<'key, 'value, 'id>, ('key, 'value) => option<'value>) => unit\n")),(0,s.kt)("p",null,"Filters out values for which function ",(0,s.kt)("inlineCode",{parentName:"p"},"f")," returned ",(0,s.kt)("inlineCode",{parentName:"p"},"None"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'module IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\nBelt.HashMap.set(s0, 1, "value1")\nBelt.HashMap.set(s0, 2, "value2")\n\nBelt.HashMap.keepMapInPlace(s0, (key, value) => key == 1 ? None : Some(value))\n')),(0,s.kt)("h2",p({},{id:"size"}),"size"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let size: t<'a, 'b, 'c> => int\n")),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"size(tbl)")," returns the number of bindings in ",(0,s.kt)("inlineCode",{parentName:"p"},"tbl"),". It takes constant time."),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'module IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\nBelt.HashMap.set(s0, 1, "value1")\nBelt.HashMap.set(s0, 2, "value2")\n\nBelt.HashMap.size(s0) == 2\n')),(0,s.kt)("h2",p({},{id:"toarray"}),"toArray"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let toArray: t<'key, 'value, 'id> => array<('key, 'value)>\n")),(0,s.kt)("p",null,"Returns array of key value pairs."),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'module IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\nBelt.HashMap.set(s0, 1, "value1")\nBelt.HashMap.set(s0, 2, "value2")\n\nBelt.HashMap.toArray(s0) == [(1, "value1"), (2, "value2")]\n')),(0,s.kt)("h2",p({},{id:"keystoarray"}),"keysToArray"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let keysToArray: t<'key, 'a, 'b> => array<'key>\n")),(0,s.kt)("p",null,"Returns array of keys."),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'module IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\nBelt.HashMap.set(s0, 1, "value1")\nBelt.HashMap.set(s0, 2, "value2")\n\nBelt.HashMap.keysToArray(s0) == [1, 2]\n')),(0,s.kt)("h2",p({},{id:"valuestoarray"}),"valuesToArray"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let valuesToArray: t<'a, 'value, 'b> => array<'value>\n")),(0,s.kt)("p",null,"Returns array of values."),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'module IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet s0 = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\nBelt.HashMap.set(s0, 1, "value1")\nBelt.HashMap.set(s0, 2, "value2")\n\nBelt.HashMap.valuesToArray(s0) == ["value1", "value2"]\n')),(0,s.kt)("h2",p({},{id:"fromarray"}),"fromArray"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let fromArray: (array<('key, 'value)>, ~id: id<'key, 'id>) => t<'key, 'value, 'id>\n")),(0,s.kt)("p",null,"Creates new hash map from array of pairs."),(0,s.kt)("p",null,"Returns array of values."),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'module IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet s0 = Belt.HashMap.fromArray([(1, "value1"), (2, "value2")], ~id=module(IntHash))\nBelt.HashMap.toArray(s0) == [(1, "value1"), (2, "value2")]\n')),(0,s.kt)("h2",p({},{id:"mergemany"}),"mergeMany"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let mergeMany: (t<'key, 'value, 'id>, array<('key, 'value)>) => unit\n")),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'module IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\n\nlet hMap = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\nBelt.HashMap.mergeMany(hMap, [(1, "1"), (2, "2")])\n')),(0,s.kt)("h2",p({},{id:"getbuckethistogram"}),"getBucketHistogram"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let getBucketHistogram: t<'a, 'b, 'c> => array<int>\n")),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'module IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\nlet hMap = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\nBelt.HashMap.set(hMap, 1, "1")\n\nBelt.HashMap.getBucketHistogram(hMap)\n')),(0,s.kt)("h2",p({},{id:"logstats"}),"logStats"),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let logStats: t<'a, 'b, 'c> => unit\n")),(0,s.kt)("pre",null,(0,s.kt)("code",p({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'module IntHash = Belt.Id.MakeHashable({\n  type t = int\n  let hash = a => a\n  let eq = (a, b) => a == b\n})\nlet hMap = Belt.HashMap.make(~hintSize=10, ~id=module(IntHash))\nBelt.HashMap.set(hMap, 1, "1")\n\nBelt.HashMap.logStats(hMap)\n')))}h.isMDXComponent=!0,h.frontmatter={__ghEditHref:"https://github.com/rescript-idea/rescript-lang.org-chinese-translation/tree/chinese-translation/pages/docs-cn/manual/latest/api/belt/hash-map.mdx"}},73870:function(e,a,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs-cn/manual/latest/api/belt/hash-map",function(){return t(8164)}])}},function(e){e.O(0,[92888,49774,40179],(function(){return a=73870,e(e.s=a);var a}));var a=e.O();_N_E=a}]);
(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[65100],{17375:function(e,a,t){"use strict";function n(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)t=l[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)t=l[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}t.d(a,{Z:function(){return n}})},95952:function(e,a,t){"use strict";t.r(a),t.d(a,{default:function(){return k}});var n=t(17375),r=t(96156),l=(t(67294),t(3905));function i(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function s(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?i(Object(t),!0).forEach((function(a){(0,r.Z)(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}var p,o=(p="Intro",function(e){return console.warn("Component "+p+" was not imported, exported, or provided by MDXProvider as global scope"),(0,l.kt)("div",s({},e))}),m={};function k(e){var a=e.components,t=(0,n.Z)(e,["components"]);return(0,l.kt)("wrapper",s(s(s({},m),t),{},{components:a,mdxType:"MDXLayout"}),(0,l.kt)("h1",s({},{id:"array"}),"Array"),(0,l.kt)(o,{mdxType:"Intro"},(0,l.kt)("p",null,"Utililites for ",(0,l.kt)("inlineCode",{parentName:"p"},"Array")," functions.")),(0,l.kt)("h3",s({},{id:"note-about-index-syntax"}),"Note about index syntax"),(0,l.kt)("p",null,"Code like ",(0,l.kt)("inlineCode",{parentName:"p"},"arr[0]")," does ",(0,l.kt)("em",{parentName:"p"},"not")," compile to JavaScript ",(0,l.kt)("inlineCode",{parentName:"p"},"arr[0]"),". ReScript transforms the ",(0,l.kt)("inlineCode",{parentName:"p"},"[]")," index syntax into a function: ",(0,l.kt)("inlineCode",{parentName:"p"},"Array.get(arr, 0)"),". By default, this uses the default standard library's ",(0,l.kt)("inlineCode",{parentName:"p"},"Array.get")," function, which may raise an exception if the index isn't found. If you ",(0,l.kt)("inlineCode",{parentName:"p"},"open Belt"),", it will use the ",(0,l.kt)("inlineCode",{parentName:"p"},"Belt.Array.get")," function which returns options instead of raising exceptions. ",(0,l.kt)("a",s({parentName:"p"},{href:"../belt.mdx#array-access-runtime-safety"}),"See this for more information"),"."),(0,l.kt)("h2",s({},{id:"length"}),"length"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let length: array<'a> => int\n")),(0,l.kt)("p",null,"return the size of the array"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'// Returns 1\nBelt.Array.length(["test"])\n')),(0,l.kt)("h2",s({},{id:"size"}),"size"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let size: array<'a> => int\n")),(0,l.kt)("p",null,"See Belt_Array.length"),(0,l.kt)("h2",s({},{id:"get"}),"get"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let get: (array<'a>, int) => option<'a>\n")),(0,l.kt)("p",null,"If ",(0,l.kt)("inlineCode",{parentName:"p"},"i <= 0 <= length(arr)")," returns ",(0,l.kt)("inlineCode",{parentName:"p"},"Some(value)")," where ",(0,l.kt)("inlineCode",{parentName:"p"},"value")," is the item at index ",(0,l.kt)("inlineCode",{parentName:"p"},"i"),".\nIf ",(0,l.kt)("inlineCode",{parentName:"p"},"i")," is out of range returns ",(0,l.kt)("inlineCode",{parentName:"p"},"None")),(0,l.kt)("h2",s({},{id:"getexn"}),"getExn"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let getExn: (array<'a>, int) => 'a\n")),(0,l.kt)("p",null,"Raise an exception if ",(0,l.kt)("inlineCode",{parentName:"p"},"i")," is out of range.\nOtherwise return the value at index ",(0,l.kt)("inlineCode",{parentName:"p"},"i")," in ",(0,l.kt)("inlineCode",{parentName:"p"},"arr"),"."),(0,l.kt)("h2",s({},{id:"getunsafe"}),"getUnsafe"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let getUnsafe: (array<'a>, int) => 'a\n")),(0,l.kt)("p",null,"Unsafe"),(0,l.kt)("p",null,"no bounds checking; this would cause type error if ",(0,l.kt)("inlineCode",{parentName:"p"},"i")," does not stay within range"),(0,l.kt)("h2",s({},{id:"getundefined"}),"getUndefined"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let getUndefined: (array<'a>, int) => Js.undefined<'a>\n")),(0,l.kt)("p",null,"It does the samething in the runtime as ",(0,l.kt)("inlineCode",{parentName:"p"},"Belt_Array.getUnsafe")," it is type safe since the return type still track whether it is in range or not"),(0,l.kt)("h2",s({},{id:"set"}),"set"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let set: (array<'a>, int, 'a) => bool\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"set(arr, n, x)")," modifies ",(0,l.kt)("inlineCode",{parentName:"p"},"arr")," in place; it replaces the nth element of ",(0,l.kt)("inlineCode",{parentName:"p"},"arr")," with ",(0,l.kt)("inlineCode",{parentName:"p"},"x"),"."),(0,l.kt)("p",null,"Returns false means not updated due to out of range."),(0,l.kt)("h2",s({},{id:"setexn"}),"setExn"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let setExn: (array<'a>, int, 'a) => unit\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"setExn(arr, i, x)")," raise an exception if ",(0,l.kt)("inlineCode",{parentName:"p"},"i")," is out of range."),(0,l.kt)("h2",s({},{id:"setunsafe"}),"setUnsafe"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let setUnsafe: (array<'a>, int, 'a) => unit\n")),(0,l.kt)("h2",s({},{id:"shuffleinplace"}),"shuffleInPlace"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let shuffleInPlace: array<'a> => unit\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"shuffleInPlace(arr)")," randomly re-orders the items in ",(0,l.kt)("inlineCode",{parentName:"p"},"arr")),(0,l.kt)("h2",s({},{id:"shuffle"}),"shuffle"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let shuffle: array<'a> => array<'a>\n")),(0,l.kt)("p",null,"Returns a fresh array with items in original array randomly shuffled."),(0,l.kt)("h2",s({},{id:"reverseinplace"}),"reverseInPlace"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let reverseInPlace: array<'a> => unit\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"reverseInPlace(arr)")," reverses items in ",(0,l.kt)("inlineCode",{parentName:"p"},"arr")," in place."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"let arr = [10, 11, 12, 13, 14]\n\nlet () = Belt.Array.reverseInPlace(arr)\n\narr == [14, 13, 12, 11, 10]\n")),(0,l.kt)("h2",s({},{id:"reverse"}),"reverse"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let reverse: array<'a> => array<'a>\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"reverse(arr)")," returns a fresh array with items in arr in reverse order."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"Belt.Array.reverse([10, 11, 12, 13, 14]) == [14, 13, 12, 11, 10]\n")),(0,l.kt)("h2",s({},{id:"makeuninitialized"}),"makeUninitialized"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let makeUninitialized: int => array<Js.undefined<'a>>\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"makeUninitialized(n)")," creates an array of length ",(0,l.kt)("inlineCode",{parentName:"p"},"n")," filled with the undefined value. You must specify the type of data that will eventually fill the array."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"let arr: array<Js.undefined<string>> = Belt.Array.makeUninitialized(5)\n\nBelt.Array.getExn(arr, 0) == Js.undefined\n")),(0,l.kt)("h2",s({},{id:"makeuninitializedunsafe"}),"makeUninitializedUnsafe"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let makeUninitializedUnsafe: int => array<'a>\n")),(0,l.kt)("p",null,"Unsafe"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'let arr = Belt.Array.makeUninitializedUnsafe(5)\n\nJs.log(Belt.Array.getExn(arr, 0)) // undefined\n\nBelt.Array.setExn(arr, 0, "example")\n\nJs.log(Belt.Array.getExn(arr, 0) == "example")\n')),(0,l.kt)("h2",s({},{id:"make"}),"make"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let make: (int, 'a) => array<'a>\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"make(n, e)")," return an array of size ",(0,l.kt)("inlineCode",{parentName:"p"},"n")," filled with value ",(0,l.kt)("inlineCode",{parentName:"p"},"e"),".\nReturns an empty array when ",(0,l.kt)("inlineCode",{parentName:"p"},"n")," is negative."),(0,l.kt)("h2",s({},{id:"range"}),"range"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let range: (int, int) => array<int>\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"range(start, finish)")," create an inclusive array."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"Belt.Array.range(0, 3) == [0, 1, 2, 3]\n\nBelt.Array.range(3, 0) == []\n\nBelt.Array.range(3, 3) == [3]\n")),(0,l.kt)("h2",s({},{id:"rangeby"}),"rangeBy"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let rangeBy: (int, int, ~step: int) => array<int>\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"rangeBy(start, finish, ~step)")),(0,l.kt)("p",null,"Returns empty array when step is 0 or negative. It also return an empty array when ",(0,l.kt)("inlineCode",{parentName:"p"},"start > finish"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"Belt.Array.rangeBy(0, 10, ~step=3) == [0, 3, 6, 9]\n\nBelt.Array.rangeBy(0, 12, ~step=3) == [0, 3, 6, 9, 12]\n\nBelt.Array.rangeBy(33, 0, ~step=1) == []\n\nBelt.Array.rangeBy(33, 0, ~step=-1) == []\n\nBelt.Array.rangeBy(3, 12, ~step=-1) == []\n\nBelt.Array.rangeBy(3, 3, ~step=0) == []\n\nBelt.Array.rangeBy(3, 3, ~step=1) == [3]\n")),(0,l.kt)("h2",s({},{id:"makebyu"}),"makeByU"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let makeByU: (int, (. int) => 'a) => array<'a>\n")),(0,l.kt)("h2",s({},{id:"makeby"}),"makeBy"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let makeBy: (int, int => 'a) => array<'a>\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"makeBy(n, f)")),(0,l.kt)("p",null,"Return an empty array when n is negative return an array of size n populated by ",(0,l.kt)("inlineCode",{parentName:"p"},"f(i)")," start from ",(0,l.kt)("inlineCode",{parentName:"p"},"0")," to ",(0,l.kt)("inlineCode",{parentName:"p"},"n - 1"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"Belt.Array.makeBy(5, (i) => i) == [0, 1, 2, 3, 4]\n\nBelt.Array.makeBy(5, (i) => i * i) == [0, 1, 4, 9, 16]\n")),(0,l.kt)("h2",s({},{id:"makebyandshuffleu"}),"makeByAndShuffleU"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let makeByAndShuffleU: (int, (. int) => 'a) => array<'a>\n")),(0,l.kt)("h2",s({},{id:"makebyandshuffle"}),"makeByAndShuffle"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let makeByAndShuffle: (int, int => 'a) => array<'a>\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"makeByAndShuffle(n, f)")),(0,l.kt)("p",null,"Equivalent to ",(0,l.kt)("inlineCode",{parentName:"p"},"shuffle(makeBy(n, f))")),(0,l.kt)("h2",s({},{id:"zip"}),"zip"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let zip: (array<'a>, array<'b>) => array<('a, 'b)>\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"zip(a, b)")),(0,l.kt)("p",null,"Create an array of pairs from corresponding elements of a and b. Stop with the shorter array."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"Belt.Array.zip([1, 2], [3, 4, 5]) == [(1, 3), (2, 4)]\n")),(0,l.kt)("h2",s({},{id:"zipbyu"}),"zipByU"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let zipByU: (array<'a>, array<'b>, (. 'a, 'b) => 'c) => array<'c>\n")),(0,l.kt)("h2",s({},{id:"zipby"}),"zipBy"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let zipBy: (array<'a>, array<'b>, ('a, 'b) => 'c) => array<'c>\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"zipBy(xs, ys, f)")),(0,l.kt)("p",null,"Create an array by applying ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," to corresponding elements of ",(0,l.kt)("inlineCode",{parentName:"p"},"xs")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"ys"),". Stops with shorter array."),(0,l.kt)("p",null,"Equivalent to ",(0,l.kt)("inlineCode",{parentName:"p"},"map(zip(xs, ys), ((a, b)) => f(a, b))")),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"Belt.Array.zipBy([1, 2, 3], [4, 5], (a, b) => 2 * a + b) == [6, 9]\n")),(0,l.kt)("h2",s({},{id:"unzip"}),"unzip"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let unzip: array<('a, 'b)> => (array<'a>, array<'b>)\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"unzip(a)")," takes an array of pairs and creates a pair of arrays. The first array contains all the first items of the pairs; the second array contains all the second items."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"Belt.Array.unzip([(1, 2), (3, 4)]) == ([1, 3], [2, 4])\n\nBelt.Array.unzip([(1, 2), (3, 4), (5, 6), (7, 8)]) == ([1, 3, 5, 7], [2, 4, 6, 8])\n")),(0,l.kt)("h2",s({},{id:"concat"}),"concat"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let concat: (array<'a>, array<'a>) => array<'a>\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"concat(xs, ys)")),(0,l.kt)("p",null,"Returns a fresh array containing the concatenation of the arrays ",(0,l.kt)("inlineCode",{parentName:"p"},"v1")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"v2"),";so even if ",(0,l.kt)("inlineCode",{parentName:"p"},"v1")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"v2")," is empty; it can not be shared"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'Belt.Array.concat([1, 2, 3], [4, 5]) == [1, 2, 3, 4, 5]\n\nBelt.Array.concat([], ["a", "b", "c"]) == ["a", "b", "c"]\n')),(0,l.kt)("h2",s({},{id:"concatmany"}),"concatMany"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let concatMany: array<array<'a>> => array<'a>\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"concatMany(xss)")),(0,l.kt)("p",null,"Returns a fresh array as the concatenation of ",(0,l.kt)("inlineCode",{parentName:"p"},"xss")," (an array of arrays)"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"Belt.Array.concatMany([[1, 2, 3], [4, 5, 6], [7, 8]]) == [1, 2, 3, 4, 5, 6, 7, 8]\n")),(0,l.kt)("h2",s({},{id:"slice"}),"slice"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let slice: (array<'a>, ~offset: int, ~len: int) => array<'a>\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"slice(xs, offset, len)")," creates a new array with the len elements of ",(0,l.kt)("inlineCode",{parentName:"p"},"xs"),"\nstarting at ",(0,l.kt)("inlineCode",{parentName:"p"},"offset")," for ",(0,l.kt)("inlineCode",{parentName:"p"},"offset")," can be negative;and is evaluated as\n",(0,l.kt)("inlineCode",{parentName:"p"},"length(xs) - offset(slice, xs) - 1(1)")," means get the last element as a\nsingleton array ",(0,l.kt)("inlineCode",{parentName:"p"},"slice(xs, ~-len, len)")," will return a copy of the array if the\narray does not have enough data; ",(0,l.kt)("inlineCode",{parentName:"p"},"slice")," extracts through the end of sequence."),(0,l.kt)("p",null,"if ",(0,l.kt)("inlineCode",{parentName:"p"},"len")," is negative; returns the empty array."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"Belt.Array.slice([10, 11, 12, 13, 14, 15, 16], ~offset=2, ~len=3) == [12, 13, 14]\n\nBelt.Array.slice([10, 11, 12, 13, 14, 15, 16], ~offset=-4, ~len=3) == [13, 14, 15]\n\nBelt.Array.slice([10, 11, 12, 13, 14, 15, 16], ~offset=4, ~len=9) == [14, 15, 16]\n")),(0,l.kt)("h2",s({},{id:"slicetoend"}),"sliceToEnd"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let sliceToEnd: (array<'a>, int) => array<'a>\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"sliceToEnd(xs, offset)")," creates a new array with the elements of ",(0,l.kt)("inlineCode",{parentName:"p"},"xs")," starting at ",(0,l.kt)("inlineCode",{parentName:"p"},"offset")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"offset")," can be negative; and is evaluated as ",(0,l.kt)("inlineCode",{parentName:"p"},"length(xs) - offset(sliceToEnd, xs) - 1")," means get the last element as a singleton array"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"sliceToEnd(xs, 0)")," will return a copy of the array"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"Belt.Array.sliceToEnd([10, 11, 12, 13, 14, 15, 16], 2) == [12, 13, 14, 15, 16]\n\nBelt.Array.sliceToEnd([10, 11, 12, 13, 14, 15, 16], -4) == [13, 14, 15, 16]\n")),(0,l.kt)("h2",s({},{id:"copy"}),"copy"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let copy: array<'a> => array<'a>\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"copy(a)")),(0,l.kt)("p",null,"Returns a copy of a; that is; a fresh array containing the same elements as a."),(0,l.kt)("h2",s({},{id:"fill"}),"fill"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let fill: (array<'a>, ~offset: int, ~len: int, 'a) => unit\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"fill(arr, ~offset, ~len, x)")),(0,l.kt)("p",null,"Modifies ",(0,l.kt)("inlineCode",{parentName:"p"},"arr")," in place, storing ",(0,l.kt)("inlineCode",{parentName:"p"},"x")," in elements number ",(0,l.kt)("inlineCode",{parentName:"p"},"offset")," to ",(0,l.kt)("inlineCode",{parentName:"p"},"offset + len - 1"),".\n",(0,l.kt)("inlineCode",{parentName:"p"},"offset")," can be negative; and is evaluated as ",(0,l.kt)("inlineCode",{parentName:"p"},"length(arr - offset)")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"fill(arr, ~offset=-1, ~len=1)")," means fill the last element, if the array does not have enough data; ",(0,l.kt)("inlineCode",{parentName:"p"},"fill")," will ignore it"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"let arr = Belt.Array.makeBy(5, (i) => i)\n\nBelt.Array.fill(arr, ~offset=2, ~len=2, 9)\n\narr == [0, 1, 9, 9, 4]\n\nBelt.Array.fill(arr, ~offset=7, ~len=2, 8)\n\narr == [0, 1, 9, 9, 4]\n")),(0,l.kt)("h2",s({},{id:"blit"}),"blit"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let blit:\n  (\n    ~src: array<'a>,\n    ~srcOffset: int,\n    ~dst: array<'a>,\n    ~dstOffset: int,\n    ~len: int\n  ) =>\n  unit\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"blit(~src=v1, ~srcOffset=o1, ~dst=v2, ~dstOffset=o2, ~len)")),(0,l.kt)("p",null,"copies ",(0,l.kt)("inlineCode",{parentName:"p"},"len")," elements from array ",(0,l.kt)("inlineCode",{parentName:"p"},"v1"),";starting at element number ",(0,l.kt)("inlineCode",{parentName:"p"},"o1"),";to array ",(0,l.kt)("inlineCode",{parentName:"p"},"v2"),", starting at element number ",(0,l.kt)("inlineCode",{parentName:"p"},"o2"),"."),(0,l.kt)("p",null,"It works correctly even if ",(0,l.kt)("inlineCode",{parentName:"p"},"v1")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"v2")," are the same array;and the source and destination chunks overlap."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"offset")," can be negative; ",(0,l.kt)("inlineCode",{parentName:"p"},"-1")," means ",(0,l.kt)("inlineCode",{parentName:"p"},"len - 1"),"; if ",(0,l.kt)("inlineCode",{parentName:"p"},"len + offset")," is still negative;it will be set as 0"),(0,l.kt)("p",null,"For each of the examples;presume that ",(0,l.kt)("inlineCode",{parentName:"p"},"v1 == [10, 11, 12, 13, 14, 15, 16, 17]")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"v2 == [20, 21, 22, 23, 24, 25, 26, 27]"),". The result shown is the content of the destination array."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"let v1 = [10, 11, 12, 13, 14, 15, 16, 17]\nlet v2 = [20, 21, 22, 23, 24, 25, 26, 27]\n\nBelt.Array.blit(~src=v1, ~srcOffset=4, ~dst=v2, ~dstOffset=2, ~len=3)\nv2 == [20, 21, 14, 15, 16, 25, 26, 27]\n\nBelt.Array.blit(~src=v1, ~srcOffset=4, ~dst=v1, ~dstOffset=2, ~len=3)\nv1 == [10, 11, 14, 15, 16, 15, 16, 17]\n")),(0,l.kt)("h2",s({},{id:"blitunsafe"}),"blitUnsafe"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let blitUnsafe: (~src: array<'a>, ~srcOffset: int, ~dst: array<'a>, ~dstOffset: int, ~len: int) => unit\n")),(0,l.kt)("p",null,"Unsafe blit without bounds checking."),(0,l.kt)("h2",s({},{id:"foreachu"}),"forEachU"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let forEachU: (array<'a>, (. 'a) => unit) => unit\n")),(0,l.kt)("h2",s({},{id:"foreach"}),"forEach"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let forEach: (array<'a>, 'a => unit) => unit\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"forEach(xs, f)")),(0,l.kt)("p",null,"Call ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," on each element of ",(0,l.kt)("inlineCode",{parentName:"p"},"xs")," from the beginning to end. ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," returns ",(0,l.kt)("inlineCode",{parentName:"p"},"unit"),";so no new array is created. Use ",(0,l.kt)("inlineCode",{parentName:"p"},"forEach")," when you are primarily concerned with repetitively creating side effects."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'Belt.Array.forEach(["a", "b", "c"], x => Js.log("Item: " ++ x))\n\n/*\n  prints:\n  Item: a\n  Item: b\n  Item: c\n*/\nlet total = ref(0)\n\nBelt.Array.forEach([1, 2, 3, 4], x => total := total.contents + x)\n\ntotal.contents == 1 + 2 + 3 + 4\n')),(0,l.kt)("h2",s({},{id:"mapu"}),"mapU"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let mapU: (array<'a>, (. 'a) => 'b) => array<'b>\n")),(0,l.kt)("h2",s({},{id:"map"}),"map"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let map: (array<'a>, 'a => 'b) => array<'b>\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"map(xs, f)")),(0,l.kt)("p",null,"Returns a new array by calling ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," for each element of ",(0,l.kt)("inlineCode",{parentName:"p"},"xs")," from the beginning to end."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"Belt.Array.map([1, 2], (x) => x + 1) == [3, 4]\n")),(0,l.kt)("h2",s({},{id:"getbyu"}),"getByU"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let getByU: (array<'a>, (. 'a) => bool) => option<'a>\n")),(0,l.kt)("h2",s({},{id:"getby"}),"getBy"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let getBy: (array<'a>, 'a => bool) => option<'a>\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"getBy(xs, p)")),(0,l.kt)("p",null,"Returns ",(0,l.kt)("inlineCode",{parentName:"p"},"Some(value)")," for the first value in ",(0,l.kt)("inlineCode",{parentName:"p"},"xs")," that satisifies the predicate function ",(0,l.kt)("inlineCode",{parentName:"p"},"p"),"; returns ",(0,l.kt)("inlineCode",{parentName:"p"},"None")," if no element satisifies the function."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"Belt.Array.getBy([1, 4, 3, 2], (x) => mod(x, 2) == 0) == Some(4)\nBelt.Array.getBy([15, 13, 11], (x) => mod(x, 2) == 0) == None\n")),(0,l.kt)("h2",s({},{id:"getindexbyu"}),"getIndexByU"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let getIndexByU: (array<'a>, (. 'a) => bool) => option<int>\n")),(0,l.kt)("h2",s({},{id:"getindexby"}),"getIndexBy"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let getIndexBy: (array<'a>, 'a => bool) => option<int>\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"getIndexBy(xs, p)")),(0,l.kt)("p",null,"returns ",(0,l.kt)("inlineCode",{parentName:"p"},"Some(index)")," for the first value in ",(0,l.kt)("inlineCode",{parentName:"p"},"xs")," that satisifies the predicate function ",(0,l.kt)("inlineCode",{parentName:"p"},"p"),";\nreturns ",(0,l.kt)("inlineCode",{parentName:"p"},"None")," if no element satisifies the function."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"Belt.Array.getIndexBy([1, 4, 3, 2], (x) => mod(x, 2) == 0) == Some(1)\nBelt.Array.getIndexBy([15, 13, 11], (x) => mod(x, 2) == 0) == None\n")),(0,l.kt)("h2",s({},{id:"keepu"}),"keepU"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let keepU: (array<'a>, (. 'a) => bool) => array<'a>\n")),(0,l.kt)("h2",s({},{id:"keep"}),"keep"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let keep: (array<'a>, 'a => bool) => array<'a>\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"keep(xs, p)")),(0,l.kt)("p",null,"Returns a new array that keep all elements satisfy ",(0,l.kt)("inlineCode",{parentName:"p"},"p"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"Belt.Array.keep([1, 2, 3], (x) => mod(x, 2) == 0) == [2]\n")),(0,l.kt)("h2",s({},{id:"keepwithindexu"}),"keepWithIndexU"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let keepWithIndexU: (array<'a>, (. 'a, int) => bool) => array<'a>\n")),(0,l.kt)("h2",s({},{id:"keepwithindex"}),"keepWithIndex"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let keepWithIndex: (array<'a>, ('a, int) => bool) => array<'a>\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"keepWithIndex(xs, p)")),(0,l.kt)("p",null,"Returns a new array that keep all elements satisfy ",(0,l.kt)("inlineCode",{parentName:"p"},"p"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"Belt.Array.keepWithIndex([1, 2, 3], (_x, i) => i == 1) == [2]\n")),(0,l.kt)("h2",s({},{id:"keepmapu"}),"keepMapU"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let keepMapU: (array<'a>, (. 'a) => option<'b>) => array<'b>\n")),(0,l.kt)("h2",s({},{id:"keepmap"}),"keepMap"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let keepMap: (array<'a>, 'a => option<'b>) => array<'b>\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"keepMap(xs, p)")),(0,l.kt)("p",null,"Returns a new array that keep all elements that return a non-None applied ",(0,l.kt)("inlineCode",{parentName:"p"},"p"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"Belt.Array.keepMap([1, 2, 3], x =>\n  if mod(x, 2) == 0 {\n    Some(x)\n  } else {\n    None\n  }\n)\n== [2]\n")),(0,l.kt)("h2",s({},{id:"foreachwithindexu"}),"forEachWithIndexU"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let forEachWithIndexU: (array<'a>, (. int, 'a) => unit) => unit\n")),(0,l.kt)("h2",s({},{id:"foreachwithindex"}),"forEachWithIndex"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let forEachWithIndex: (array<'a>, (int, 'a) => unit) => unit\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"forEachWithIndex(xs, f)")),(0,l.kt)("p",null,"The same as ",(0,l.kt)("inlineCode",{parentName:"p"},"Belt_Array.forEach"),";\nexcept that ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," is supplied two arguments: the index starting from 0 and the element from ",(0,l.kt)("inlineCode",{parentName:"p"},"xs"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'Belt.Array.forEachWithIndex(["a", "b", "c"], (i, x) => Js.log("Item " ++ Belt.Int.toString(i) ++ " is " ++ x))\n\n/*\n  prints:\n  Item 0 is a\n  Item 1 is b\n  Item 2 is cc\n*/\nlet total = ref(0)\n\nBelt.Array.forEachWithIndex([10, 11, 12, 13], (i, x) => total := total.contents + x + i)\n\ntotal.contents == 0 + 10 + 1 + 11 + 2 + 12 + 3 + 13\n')),(0,l.kt)("h2",s({},{id:"mapwithindexu"}),"mapWithIndexU"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let mapWithIndexU: (array<'a>, (. int, 'a) => 'b) => array<'b>\n")),(0,l.kt)("h2",s({},{id:"mapwithindex"}),"mapWithIndex"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let mapWithIndex: (array<'a>, (int, 'a) => 'b) => array<'b>\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"mapWithIndex(xs, f)")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"mapWithIndex(xs, f)")," applies ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," to each element of ",(0,l.kt)("inlineCode",{parentName:"p"},"xs"),". Function ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," takes two arguments: the index starting from 0 and the element from ",(0,l.kt)("inlineCode",{parentName:"p"},"xs"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"Belt.Array.mapWithIndex([1, 2, 3], (i, x) => i + x) == [0 + 1, 1 + 2, 2 + 3]\n")),(0,l.kt)("h2",s({},{id:"partitionu"}),"partitionU"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let partitionU: (array<'a>, (. 'a) => bool) => (array<'a>, array<'a>)\n")),(0,l.kt)("h2",s({},{id:"partition"}),"partition"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let partition: (array<'a>, 'a => bool) => (array<'a>, array<'a>)\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"partition(f, a)")," split array into tuple of two arrays based on predicate ",(0,l.kt)("inlineCode",{parentName:"p"},"f"),"; first of tuple where predicate cause true, second where predicate cause false"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"Belt.Array.partition([1, 2, 3, 4, 5], (x) => mod(x, 2) == 0) == ([2, 4], [1, 3, 5])\n\nBelt.Array.partition([1, 2, 3, 4, 5], (x) => mod(x, 2) != 0) == ([1, 3, 5], [2, 4])\n")),(0,l.kt)("h2",s({},{id:"reduceu"}),"reduceU"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let reduceU: (array<'b>, 'a, (. 'a, 'b) => 'a) => 'a\n")),(0,l.kt)("h2",s({},{id:"reduce"}),"reduce"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let reduce: (array<'b>, 'a, ('a, 'b) => 'a) => 'a\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"reduce(xs, init, f)")),(0,l.kt)("p",null,"Applies ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," to each element of ",(0,l.kt)("inlineCode",{parentName:"p"},"xs")," from beginning to end. Function ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," has two parameters: the item from the list and an \u201caccumulator\u201d; which starts with a value of ",(0,l.kt)("inlineCode",{parentName:"p"},"init"),". ",(0,l.kt)("inlineCode",{parentName:"p"},"reduce")," returns the final value of the accumulator."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'Belt.Array.reduce([2, 3, 4], 1, (a, b) => a + b) == 10\n\nBelt.Array.reduce(["a", "b", "c", "d"], "", (a, b) => a ++ b) == "abcd"\n')),(0,l.kt)("h2",s({},{id:"reducereverseu"}),"reduceReverseU"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let reduceReverseU: (array<'b>, 'a, (. 'a, 'b) => 'a) => 'a\n")),(0,l.kt)("h2",s({},{id:"reducereverse"}),"reduceReverse"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let reduceReverse: (array<'b>, 'a, ('a, 'b) => 'a) => 'a\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"reduceReverse(xs, init, f)")),(0,l.kt)("p",null,"Works like ",(0,l.kt)("inlineCode",{parentName:"p"},"Belt_Array.reduce"),"; except that function ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," is applied to each item of ",(0,l.kt)("inlineCode",{parentName:"p"},"xs")," from the last back to the first."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'Belt.Array.reduceReverse(["a", "b", "c", "d"], "", (a, b) => a ++ b) == "dcba"\n')),(0,l.kt)("h2",s({},{id:"reducereverse2u"}),"reduceReverse2U"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let reduceReverse2U: (array<'a>, array<'b>, 'c, (. 'c, 'a, 'b) => 'c) => 'c\n")),(0,l.kt)("h2",s({},{id:"reducereverse2"}),"reduceReverse2"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let reduceReverse2: (array<'a>, array<'b>, 'c, ('c, 'a, 'b) => 'c) => 'c\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"reduceReverse2(xs, ys, init, f)")),(0,l.kt)("p",null,"Reduces two arrays xs and ys;taking items starting at ",(0,l.kt)("inlineCode",{parentName:"p"},"min(length(xs), length(ys))")," down to and including zero."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"Belt.Array.reduceReverse2([1, 2, 3], [1, 2], 0, (acc, x, y) => acc + x + y) == 6\n")),(0,l.kt)("h2",s({},{id:"reducewithindexu"}),"reduceWithIndexU"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let reduceWithIndexU: (array<'a>, 'b, (. 'b, 'a, int) => 'b) => 'b\n")),(0,l.kt)("h2",s({},{id:"reducewithindex"}),"reduceWithIndex"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let reduceWithIndex: (array<'a>, 'b, ('b, 'a, int) => 'b) => 'b\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"reduceWithIndex(xs, f)")),(0,l.kt)("p",null,"Applies ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," to each element of ",(0,l.kt)("inlineCode",{parentName:"p"},"xs")," from beginning to end. Function ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," has three parameters: the item from the array and an \u201caccumulator\u201d, which starts with a value of ",(0,l.kt)("inlineCode",{parentName:"p"},"init")," and the index of each element. ",(0,l.kt)("inlineCode",{parentName:"p"},"reduceWithIndex")," returns the final value of the accumulator."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"Belt.Array.reduceWithIndex([1, 2, 3, 4], 0, (acc, x, i) => acc + x + i) == 16\n")),(0,l.kt)("h2",s({},{id:"someu"}),"someU"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let someU: (array<'a>, (. 'a) => bool) => bool\n")),(0,l.kt)("h2",s({},{id:"some"}),"some"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let some: (array<'a>, 'a => bool) => bool\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"some(xs, p)")),(0,l.kt)("p",null,"Returns true if at least one of the elements in ",(0,l.kt)("inlineCode",{parentName:"p"},"xs")," satifies ",(0,l.kt)("inlineCode",{parentName:"p"},"p"),"; where ",(0,l.kt)("inlineCode",{parentName:"p"},"p")," is a predicate: a function taking an element and returning a ",(0,l.kt)("inlineCode",{parentName:"p"},"bool"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"Belt.Array.some([2, 3, 4], (x) => mod(x, 2) == 1) == true\n\nBelt.Array.some([(-1), (-3), (-5)], (x) => x > 0) == false\n")),(0,l.kt)("h2",s({},{id:"everyu"}),"everyU"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let everyU: (array<'a>, (. 'a) => bool) => bool\n")),(0,l.kt)("h2",s({},{id:"every"}),"every"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let every: (array<'a>, 'a => bool) => bool\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"every(xs, p)")),(0,l.kt)("p",null,"Returns ",(0,l.kt)("inlineCode",{parentName:"p"},"true")," if all elements satisfy ",(0,l.kt)("inlineCode",{parentName:"p"},"p"),"; where ",(0,l.kt)("inlineCode",{parentName:"p"},"p")," is a predicate: a function taking an element and returning a ",(0,l.kt)("inlineCode",{parentName:"p"},"bool"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"Belt.Array.every([1, 3, 5], (x) => mod(x, 2) == 1) == true\n\nBelt.Array.every([1, (-3), 5], (x) => x > 0) == false\n")),(0,l.kt)("h2",s({},{id:"every2u"}),"every2U"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let every2U: (array<'a>, array<'b>, (. 'a, 'b) => bool) => bool\n")),(0,l.kt)("h2",s({},{id:"every2"}),"every2"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let every2: (array<'a>, array<'b>, ('a, 'b) => bool) => bool\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"every2(xs, ys, p)")),(0,l.kt)("p",null,"returns true if ",(0,l.kt)("inlineCode",{parentName:"p"},"p(xi, yi)")," is true for all pairs of elements up to the shorter length (i.e. ",(0,l.kt)("inlineCode",{parentName:"p"},"min(length(xs), length(ys))"),")"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"Belt.Array.every2([1, 2, 3], [0, 1], (a, b) => a > b) == true\n\nBelt.Array.every2([], [1], (x, y) => x > y) == true\n\nBelt.Array.every2([2, 3], [1], (x, y) => x > y) == true\n\nBelt.Array.every2([0, 1], [5, 0], (x, y) => x > y) == false\n")),(0,l.kt)("h2",s({},{id:"some2u"}),"some2U"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let some2U: (array<'a>, array<'b>, (. 'a, 'b) => bool) => bool\n")),(0,l.kt)("h2",s({},{id:"some2"}),"some2"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let some2: (array<'a>, array<'b>, ('a, 'b) => bool) => bool\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"some2(xs, ys, p)")),(0,l.kt)("p",null,"returns true if ",(0,l.kt)("inlineCode",{parentName:"p"},"p(xi, yi)")," is true for any pair of elements up to the shorter length (i.e. ",(0,l.kt)("inlineCode",{parentName:"p"},"min(length(xs), length(ys))"),")"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"Belt.Array.some2([0, 2], [1, 0, 3], (a, b) => a > b) == true\n\nBelt.Array.some2([], [1], (x, y) => x > y) == false\n\nBelt.Array.some2([2, 3], [1, 4], (x, y) => x > y) == true\n")),(0,l.kt)("h2",s({},{id:"cmpu"}),"cmpU"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let cmpU: (array<'a>, array<'a>, (. 'a, 'a) => int) => int\n")),(0,l.kt)("h2",s({},{id:"cmp"}),"cmp"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let cmp: (array<'a>, array<'a>, ('a, 'a) => int) => int\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"cmp(xs, ys, f)")),(0,l.kt)("p",null,"Compared by length if ",(0,l.kt)("inlineCode",{parentName:"p"},"length(xs) != length(ys)"),"; returning -1 if ",(0,l.kt)("inlineCode",{parentName:"p"},"length(xs) < length(ys)")," or 1 if ",(0,l.kt)("inlineCode",{parentName:"p"},"length(xs) > length(ys)"),"\nOtherwise compare one by one ",(0,l.kt)("inlineCode",{parentName:"p"},"f(x, y)"),". ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," returns\na negative number if ",(0,l.kt)("inlineCode",{parentName:"p"},"x")," is \u201cless than\u201d ",(0,l.kt)("inlineCode",{parentName:"p"},"y"),"\nzero if ",(0,l.kt)("inlineCode",{parentName:"p"},"x")," is \u201cequal to\u201d ",(0,l.kt)("inlineCode",{parentName:"p"},"y"),"\na positive number if ",(0,l.kt)("inlineCode",{parentName:"p"},"x")," is \u201cgreater than\u201d ",(0,l.kt)("inlineCode",{parentName:"p"},"y"),"\nThe comparison returns the first non-zero result of ",(0,l.kt)("inlineCode",{parentName:"p"},"f"),";or zero if ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," returns zero for all ",(0,l.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"y"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"Belt.Array.cmp([1, 3, 5], [1, 4, 2], (a, b) => compare(a, b)) == -1\n\nBelt.Array.cmp([1, 3, 5], [1, 2, 3], (a, b) => compare(a, b)) == 1\n\nBelt.Array.cmp([1, 3, 5], [1, 3, 5], (a, b) => compare(a, b)) == 0\n")),(0,l.kt)("h2",s({},{id:"equ"}),"eqU"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let eqU: (array<'a>, array<'a>, (. 'a, 'a) => bool) => bool\n")),(0,l.kt)("h2",s({},{id:"eq"}),"eq"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let eq: (array<'a>, array<'a>, ('a, 'a) => bool) => bool\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"eq(xs, ys)")),(0,l.kt)("p",null,"return false if length is not the same\notherwise compare items one by one using ",(0,l.kt)("inlineCode",{parentName:"p"},"f(xi, yi)"),"; and return true if all results are truefalse otherwise"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"Belt.Array.eq([1, 2, 3], [(-1), (-2), (-3)], (a, b) => abs(a) == abs(b)) == true\n")),(0,l.kt)("h2",s({},{id:"truncatetolengthunsafe"}),"truncateToLengthUnsafe"),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"sig",sig:!0}),"let truncateToLengthUnsafe: (array<'a>, int) => unit\n")),(0,l.kt)("p",null,"Unsafe ",(0,l.kt)("inlineCode",{parentName:"p"},"truncateToLengthUnsafe(xs, n)")," sets length of array ",(0,l.kt)("inlineCode",{parentName:"p"},"xs")," to ",(0,l.kt)("inlineCode",{parentName:"p"},"n"),"."),(0,l.kt)("p",null,"If ",(0,l.kt)("inlineCode",{parentName:"p"},"n")," is greater than the length of ",(0,l.kt)("inlineCode",{parentName:"p"},"xs"),"; the extra elements are set to ",(0,l.kt)("inlineCode",{parentName:"p"},"Js.Null_undefined.null"),"."),(0,l.kt)("p",null,"If ",(0,l.kt)("inlineCode",{parentName:"p"},"n")," is less than zero; raises a ",(0,l.kt)("inlineCode",{parentName:"p"},"RangeError"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",s({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'let arr = ["ant", "bee", "cat", "dog", "elk"]\n\nBelt.Array.truncateToLengthUnsafe(arr, 3)\n\narr == ["ant", "bee", "cat"]\n')))}k.isMDXComponent=!0,k.frontmatter={__ghEditHref:"https://github.com/reason-association/rescript-lang.org/blob/master/pages/docs/manual/v9.0.0/api/belt/array.mdx"}},62837:function(e,a,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/manual/v9.0.0/api/belt/array",function(){return t(95952)}])}},function(e){e.O(0,[92888,49774,40179],(function(){return a=62837,e(e.s=a);var a}));var a=e.O();_N_E=a}]);
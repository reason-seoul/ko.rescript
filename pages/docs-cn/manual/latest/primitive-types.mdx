---
title: "åŸç”Ÿç±»å‹"
description: "Primitive Data Types in ReScript"
canonical: "/docs/manual/latest/primitive-types"
---

# Primitive Types | åŸç”Ÿç±»å‹

ReScript comes with the familiar primitive types like `string`, `int`, `float`, etc.

ReScriptè‡ªå¸¦æˆ‘ä»¬æ‰€ç†Ÿæ‚‰çš„åŸç”Ÿç±»å‹åƒ `string`, `int`, `float`ç­‰.

<!-- TODO: doc unit -->

## String

ReScript `string`s are delimited using **double** quotes (single quotes are reserved for the character type below).

ReScript å°†`string`é™åˆ¶ä¸ºåªå¯ä»¥ä½¿ç”¨**åŒå¼•å·**(å•å¼•å·è¢«ä¿ç•™ç”¨æ¥è¡¨ç¤ºå­—ç¬¦ç±»å‹).

<CodeTab labels={["ReScript", "JS Output"]}>

```res example
let greeting = "Hello world!"
let multilineGreeting = "Hello
 world!"
```
```js
var greeting = "Hello world!";
var multilineGreeting = "Hello\n world!";
```

</CodeTab>

To concatenate strings, use `++`:

è¿æ¥ä¸¤ä¸ªå­—ç¬¦ä¸², ç”¨`++`è¿ç®—ç¬¦:

<CodeTab labels={["ReScript", "JS Output"]}>

```res example
let greetings = "Hello " ++ "world!"
```
```js
var greetings = "Hello world!";
```

</CodeTab>

### String Interpolation | å†…å»ºå­—ç¬¦ä¸²

There's a special syntax for string that allows

æœ‰ä¸€ä¸ªç‰¹æ®Šçš„å­—ç¬¦ä¸²è¯­æ³•, ä½¿å¾—:

- multiline string just like before
- no special character escaping
- Interpolation
- Proper unicode handling


- å’Œå…ˆå‰ä¸€æ ·çš„å¤šè¡Œå­—ç¬¦ä¸²
- æ²¡æœ‰ç‰¹æ®Šçš„è½¬ä¹‰å­—ç¬¦
- å†…å»º
- æ›´å¥½çš„unicodeå¤„ç†

<CodeTab labels={["ReScript", "JS Output"]}>

```res example
let name = "Joe"

let greeting = `Hello
World
ğŸ‘‹
${name}
`
```
```js
var name = "Joe";

var greeting = "Hello\nWorld\nğŸ‘‹\n" + name + "\n";
```

</CodeTab>

This is just like JavaScript's backtick string interpolation, except without needing to escape special characters.

è¿™å°±åƒJavaScriptçš„åå¼•å·å­—ç¬¦ä¸²æ’å€¼, åªæ˜¯ä¸éœ€è¦è½¬ä¹‰ç‰¹æ®Šå­—ç¬¦. 

For interpolation, you'll have to convert the binding (`name` in the example) into a string if it isn't one. If you want the interpolation to implicitly convert a binding into a string, prepend a `j`:

å¯¹äºå†…å»ºå­—ç¬¦ä¸², å¦‚æœç»‘å®šçš„å€¼ä¸æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²(æ¯”å¦‚ä¸Šè¿°ä¾‹å­ä¸­çš„ `name`),ä½ å°±å¿…é¡»å°†å…¶è½¬æ¢æˆå­—ç¬¦ä¸². å¦‚æœä½ éœ€è¦éšå¼çš„è½¬æ¢ä¸€ä¸ªç»‘å®šåˆ°å­—ç¬¦ä¸², å¯ä»¥åœ¨å­—ç¬¦ä¸²å‰åŠ ä¸€ä¸ª `j`

<CodeTab labels={["ReScript", "JS Output"]}>

```res example
let age = 10
let message = j`Today I am $age years old.`
```
```js
var message = "Today I am " + 10 + " years old.";
```

</CodeTab>

### Usage | ç”¨æ³•

See the familiar `Js.String` API in the [API docs](api/js/string). Since a ReScript string maps to a JavaScript string, you can mix & match the string operations in both standard libraries.

åœ¨[APIæ–‡æ¡£](api/js/string)ä¸­æŸ¥çœ‹æˆ‘ä»¬ç†Ÿæ‚‰çš„ `Js.String` API. å› ä¸ºä¸€ä¸ªReScriptå­—ç¬¦æ˜ å°„å­—ç¬¦ä¸²åˆ°JavaScriptå­—ç¬¦ä¸², ä½ å¯ä»¥æ··ç”¨æˆ–æ¯”è¾ƒä¸¤ä¸ªæ ‡å‡†åº“ä¸­çš„å­—ç¬¦ä¸².

### Tips & Tricks | æŠ€å·§ & è¯€çª

**You have a good type system now**! In an untyped language, you'd often overload the meaning of string by using it as:

**ä½ ç°åœ¨æœ‰äº†ä¸€ä¸ªå¥½çš„ç±»å‹ç³»ç»Ÿäº†**! åœ¨éé™æ€ç±»å‹è¯­è¨€ä¸­, ä½ å¯èƒ½ç»å¸¸éœ€è¦é‡è½½å­—ç¬¦ä¸²çš„æ„ä¹‰, æ¯”å¦‚è¯´:

- a unique id: `var BLUE_COLOR = "blue"`
- an identifier into a data structure: `var BLUE = "blue" var RED = "red" var colors = [BLUE, RED]`
- the name of an object field: `person["age"] = 24`
- an enum: `if (audio.canPlayType() === 'probably') {...}` [(à² _à² )](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canPlayType#Return_value)
- other crazy patterns you'll soon find horrible, after getting used to ReScript's alternatives.

- ä¸€ä¸ªå•ç‹¬çš„id: `var BLUE_COLOR = "blue"`
- å°†æ ‡è¯†ç¬¦æ”¾å…¥ä¸€ä¸ªæ•°æ®ç»“æ„ä¸­: `var BLUE = "blue" var RED = "red" var colors = [BLUE, RED]`
- å¯¹è±¡çš„å±æ€§: `person["age"] = 24`
- ä½œä¸ºæšä¸¾ä½¿ç”¨: `if (audio.canPlayType() === 'probably') {...}` [(à² _à² )](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canPlayType#Return_value)
- åœ¨ä¹ æƒ¯äº†ReScriptä½œä¸ºæ›¿ä»£å“ä¹‹å, ä½ å¾ˆå¿«å°±ä¼šå‘ç°, å…¶ä»–ç–¯ç‹‚çš„æ¨¡å¼æ˜¯å¤šä¹ˆå¯æ€•.

The more you overload the poor string type, the less the type system (or a teammate) can help you! ReScript provides concise, fast and maintainable types & data structures alternatives to the use-cases above (e.g. variants, in a later section).

ä½ å¯¹å¯æ€œçš„å­—ç¬¦ä¸²ç±»å‹çš„æ„ä¹‰é‡è½½æ¬¡æ•°è¶Šå¤š, ç±»å‹ç³»ç»Ÿ(æˆ–ç§°ä¹‹ä¸ºä½ çš„é˜Ÿå‹)èƒ½å¤Ÿå¸®åŠ©ä½ çš„ç¨‹åº¦å°±è¶Šä½! ReScript ä¸ºä¸Šè¿°ä½¿ç”¨æƒ…å†µçš„ç±»å‹å’Œæ•°æ®ç»“æ„çš„æ›¿ä»£æ–¹æ¡ˆ (ä¾‹å¦‚, å˜ä½“, åœ¨åé¢çš„ç« èŠ‚) , ReScriptçš„æ–¹æ¡ˆæ˜¯ç®€æ´, å¿«é€Ÿå’Œå¯ç»´æŠ¤çš„. 

## Char | å­—ç¬¦

ReScript has a type for a string with a single letter:

ReScripté€‚ç”¨äºå•å­—æ¯çš„å­—ç¬¦ä¸²çš„ç±»å‹.

<CodeTab labels={["ReScript", "JS Output"]}>

```res example
let firstLetterOfAlphabet = 'a'
```
```js
var firstLetterOfAlphabet = /* "a" */97;
```

</CodeTab>

**Note**: Char doesn't support Unicode or UTF-8 and is therefore not recommended.

**æ³¨æ„**: Charä¸æ”¯æŒUnicodeæˆ–UTF-8, å› æ­¤ä¸æ¨èä½¿ç”¨

To convert a String to a Char, use `String.get("a", 0)`. To convert a Char to a String, use `String.make(1, 'a')`.

å¯ä»¥é€šè¿‡ `String.get("a", 0)` è½¬æ¢ä¸€ä¸ªå­—ç¬¦ä¸²åˆ°å­—ç¬¦, é€šè¿‡`String.make(1, 'a')`è½¬æ¢ä¸€ä¸ªå­—ç¬¦åˆ°å­—ç¬¦ä¸².

## Regular Expression | æ­£åˆ™è¡¨è¾¾å¼

ReScript regular expressions compile cleanly to their JavaScript counterpart:

ReScriptçš„æ­£åˆ™è¡¨è¾¾å¼ç®€æ´çš„ç¼–è¯‘åˆ°JavaScriptçš„å¯¹ç­‰ç‰©.

<CodeTab labels={["ReScript", "JS Output"]}>

```res example
let r = %re("/b/g")
```
```js
var r = /b/g;
```

</CodeTab>

A regular expression like the above has the type `Js.Re.t`. The [Js.Re](api/js/re) module contains the regular expression helpers you have seen in JS.

ä¸€ä¸ªåƒä¸Šé¢ä¸€æ ·çš„æ­£åˆ™è¡¨è¾¾å¼çš„ç±»å‹æ˜¯ `Js.Re.t`. [Js.Re](api/js/re)æ¨¡å—åŒ…æ‹¬ä¸€äº›æ­£åˆ™è¡¨è¾¾å¼çš„è¾…åŠ©å‡½æ•°, ä½ åº”è¯¥å·²ç»åœ¨JSä¸­è§è¿‡å®ƒä»¬.

## Boolean | å¸ƒå°”ç±»å‹

A ReScript boolean has the type `bool` and can be either `true` or `false`. Common operations:

ReScriptçš„å¸ƒå°”å€¼çš„ç±»å‹æ˜¯`bool`, å¯ä»¥æ˜¯`true`æˆ–`false`. ä¸€ä¸‹æ˜¯ä¸€äº›å¸¸è§çš„ä¸å¸ƒå°”å€¼æœ‰å…³çš„æ“ä½œ:

- `&&`: logical and.
- `||`: logical or.
- `!`: logical not.
- `<=`, `>=`, `<`, `>`
- `==`: structural equal, compares data structures deeply: `(1, 2) == (1, 2)` is `true`. Convenient, but use with caution.
- `===`: referential equal, compares shallowly. `(1, 2) === (1, 2)` is `false`. `let myTuple = (1, 2); myTuple === myTuple` is `true`.
- `!=`: structural unequal.
- `!==`: referential unequal.

- `&&`: é€»è¾‘ä¸.
- `||`: é€»è¾‘æˆ–.
- `!`: é€»è¾‘é.
- `<=`, `>=`, `<`, `>`
- `==`: ç»“æ„åŒ–ç›¸ç­‰, æ·±å…¥çš„æ¯”è¾ƒæ•°æ®ç»“æ„: `(1, 2) == (1, 2)` is `true`. å¾ˆæ–¹ä¾¿, ä½†ç”¨çš„æ—¶å€™éœ€è¦æ³¨æ„
- `===`: å¼•ç”¨ç›¸ç­‰, æµ…å±‚çš„æ¯”è¾ƒæ•°æ®ç»“æ„. `(1, 2) === (1, 2)` is `false`. `let myTuple = (1, 2); myTuple === myTuple` is `true`.
- `!=`: ç»“æ„åŒ–ä¸ç›¸ç­‰.
- `!==`: å¼•ç”¨ç›¸ç­‰.

ReScriptçš„ `true/false` ç¼–è¯‘åˆ° JavaScript `true/false`.

## Integers | æ•´æ•°

32-bits, truncated when necessary. We provide the usual operations on them: `+`, `-`, `*`, `/`, etc. See [Js.Int](api/js/int) for helper functions.

32ä½æ•´æ•°, å¯èƒ½åœ¨éœ€è¦çš„æ—¶å€™è¢«è£å‰ª. æˆ‘ä»¬ä¸ºå®ƒä»¬æä¾›å¸¸ç”¨çš„æ“ä½œ: `+`, `-`, `*`, `/`... . [Js.Int](api/js/int)æ¨¡å—åŒ…å«ä¸€äº›æ•´æ•°çš„è¾…åŠ©å‡½æ•°.

**Be careful when you bind to JavaScript numbers!** Since ReScript integers have a much smaller range than JavaScript numbers, data might get lost when dealing with large numbers. In those cases itâ€™s much safer to bind the numbers as **float**. Be extra mindful of this when binding to JavaScript Dates and their epoch time.

**å½“ç»‘å®šåˆ°JavaScriptæ•°å­—æ—¶è¦å°å¿ƒï¼** ç”±äºReScriptæ•´æ•°çš„èŒƒå›´æ¯”JavaScriptæ•°å­—å°å¾—å¤š, åœ¨å¤„ç†å¤§æ•°å­—æ—¶, æ•°æ®å¯èƒ½ä¼šä¸¢å¤±. åœ¨è¿™ç§æƒ…å†µä¸‹, å°†æ•°å­—ç»‘å®šä¸º**float**è¦å®‰å…¨å¾—å¤š. å½“ç»‘å®šåˆ°JavaScriptæ—¥æœŸå’Œå®ƒä»¬çš„epoch timeæ—¶è¦ç‰¹åˆ«æ³¨æ„è¿™ä¸€ç‚¹.

To improve readability, you may place underscores in the middle of numeric literals such as `1_000_000`. Note that underscores can be placed anywhere within a number, not just every three digits.

ä¸ºäº†æé«˜å¯è¯»æ€§, ä½ å¯ä»¥å°†ä¸‹åˆ’çº¿æ”¾åœ¨æ•°å­—çš„ä¸­é—´, å¦‚`1_000_000`. æ³¨æ„, ä¸‹åˆ’çº¿å¯ä»¥æ”¾åœ¨æ•°å­—çš„ä»»ä½•åœ°æ–¹, è€Œä¸æ˜¯åªæœ‰æ¯ä¸‰ä½æ•°å­—éƒ½æ‰å¯ä»¥.

## Floats | æµ®ç‚¹

Float requires other operators: `+.`, `-.`, `*.`, `/.`, etc. Like `0.5 +. 0.6`. See [Js.Float](api/js/float) for helper functions.

æµ®ç‚¹æ•°çš„è¿ç®—éœ€è¦å…¶ä»–è¿ç®—ç¬¦. `+.`, `-.`, `*.`, `/.` ... . å¦‚`0.5 +. 0.6`. å‚è§[Js.Float](api/js/float)æ¨¡å—ä¸­çš„è¾…åŠ©å‡½æ•°. 

As with integers, you may use underscores within literals to improve readability.

å’Œæ•´æ•°ä¸€æ ·, ä½ å¯ä»¥åœ¨å­—é¢å€¼ä¸Šä½¿ç”¨ä¸‹åˆ’çº¿ä»¥æé«˜å¯è¯»æ€§.

## Unit

The `unit` type has a single value, `()`. It compiles to JavaScript's `undefined`. It's a dummy type used as a placeholder in various places. You won't need it until you see it.

`unit`ç±»å‹åªæœ‰ä¸€ä¸ªå€¼, å³ `()`. å®ƒå¯ä»¥ç¼–è¯‘ä¸ºJavaScriptçš„`undefined'. å®ƒæ˜¯ä¸€ä¸ªdummyç±»å‹, å¸¸åœ¨ä¸åŒçš„åœ°æ–¹ä½œä¸ºå ä½ç¬¦ä½¿ç”¨. ä½ åªæœ‰åœ¨çœ‹åˆ°å®ƒçš„æ—¶å€™æ‰ä¼šéœ€è¦å®ƒ.

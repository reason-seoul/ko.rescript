(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[74593],{17375:function(e,t,a){"use strict";function n(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},p=Object.keys(e);for(n=0;n<p.length;n++)a=p[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var p=Object.getOwnPropertySymbols(e);for(n=0;n<p.length;n++)a=p[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}a.d(t,{Z:function(){return n}})},1289:function(e,t,a){"use strict";a.r(t),a.d(t,{default:function(){return c}});var n=a(17375),r=a(96156),p=(a(67294),a(3905));function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){(0,r.Z)(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}var i,s=(i="CodeTab",function(e){return console.warn("Component "+i+" was not imported, exported, or provided by MDXProvider as global scope"),(0,p.kt)("div",o({},e))}),u={};function c(e){var t=e.components,a=(0,n.Z)(e,["components"]);return(0,p.kt)("wrapper",o(o(o({},u),a),{},{components:t,mdxType:"MDXLayout"}),(0,p.kt)("h1",o({},{id:"type"}),"Type"),(0,p.kt)("p",null,"Types are the highlight of ReScript! They are:"),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("strong",{parentName:"li"},"Strong"),". A type can't change into another type. In JavaScript, your variable's type might change when the code runs (aka at runtime). E.g. a ",(0,p.kt)("inlineCode",{parentName:"li"},"number")," variable might change into a ",(0,p.kt)("inlineCode",{parentName:"li"},"string")," sometimes. This is an anti-feature; it makes the code much harder to understand when reading or debugging."),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("strong",{parentName:"li"},"Static"),". ReScript types are erased after compilation and don't exist at runtime. Never worry about your types dragging down performance. You don't need type info during runtime; we report all the information (especially all the type errors) during compile time. Catch the bugs earlier!"),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("strong",{parentName:"li"},"Sound"),". This is our biggest differentiator versus many other typed languages that compile to JavaScript. Our type system is guaranteed to ",(0,p.kt)("strong",{parentName:"li"},"never")," be wrong. Most type systems make a guess at the type of a value and show you a type in your editor that's sometime incorrect. We don't do that. We believe that a type system that is sometime incorrect can end up being dangerous due to expectation mismatches."),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("strong",{parentName:"li"},"Fast"),". Many developers underestimate how much of their project's build time goes into type checking. Our type checker is one of the fastest around."),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("strong",{parentName:"li"},"Inferred"),". You don't have to write down the types! ReScript can deduce them from their values. Yes, it might seem magical that we can deduce all of your program's types, without incorrectness, without your manual annotation, and do so quickly. Welcome to ReScript =).")),(0,p.kt)("p",null,"The following sections explore more of our type system."),(0,p.kt)("h2",o({},{id:"inference"}),"Inference"),(0,p.kt)("p",null,"This let-binding doesn't contain any written type:"),(0,p.kt)(s,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"let score = 10\nlet add = (a, b) => a + b\n")),(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-js"}),"var score = 10;\nfunction add(a, b) {\n  return a + b | 0;\n}\n"))),(0,p.kt)("p",null,"ReScript knows that ",(0,p.kt)("inlineCode",{parentName:"p"},"score")," is an ",(0,p.kt)("inlineCode",{parentName:"p"},"int"),", judging by the value ",(0,p.kt)("inlineCode",{parentName:"p"},"10"),". This is called ",(0,p.kt)("strong",{parentName:"p"},"inference"),". Likewise, it also knows that the ",(0,p.kt)("inlineCode",{parentName:"p"},"add")," function takes 2 ",(0,p.kt)("inlineCode",{parentName:"p"},"int"),"s and returns an ",(0,p.kt)("inlineCode",{parentName:"p"},"int"),", judging from the ",(0,p.kt)("inlineCode",{parentName:"p"},"+")," operator, which works on ints."),(0,p.kt)("h2",o({},{id:"type-annotation"}),"Type Annotation"),(0,p.kt)("p",null,"But you can also optionally write down the type, aka annotate your value:"),(0,p.kt)(s,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"let score: int = 10\n")),(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-js"}),"var score = 10;\n"))),(0,p.kt)("p",null,"If the type annotation for ",(0,p.kt)("inlineCode",{parentName:"p"},"score")," doesn't correspond to our inferred type for it, we'll show you an error during compilation time. We ",(0,p.kt)("strong",{parentName:"p"},"won't")," silently assume your type annotation is correct, unlike many other languages."),(0,p.kt)("p",null,"You can also wrap any expression in parentheses and annotate it:"),(0,p.kt)(s,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-res"}),"let myInt = 5\nlet myInt: int = 5\nlet myInt = (5: int) + (4: int)\nlet add = (x: int, y: int) : int => x + y\nlet drawCircle = (~radius as r: int): circleType => /* code here */\n")),(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-js"}),"var myInt = 9;\nfunction add(x, y) {\n  return x + y | 0;\n}\nfunction drawCircle(r) {\n  /* code here */\n}\n"))),(0,p.kt)("p",null,"Note: in the last line, ",(0,p.kt)("inlineCode",{parentName:"p"},"(~radius as r: int)")," is a labeled argument. More on this in the ",(0,p.kt)("a",o({parentName:"p"},{href:"function.md"}),"function")," page."),(0,p.kt)("h2",o({},{id:"type-alias"}),"Type Alias"),(0,p.kt)("p",null,"You can refer to a type by a different name. They'll be equivalent:"),(0,p.kt)(s,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"type scoreType = int\nlet x: scoreType = 10\n")),(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-js"}),"var x = 10;\n"))),(0,p.kt)("h2",o({},{id:"type-parameter-aka-generic"}),"Type Parameter (Aka Generic)"),(0,p.kt)("p",null,"Types can accept parameters, akin to generics in other languages. The parameters' names ",(0,p.kt)("strong",{parentName:"p"},"need")," to start with ",(0,p.kt)("inlineCode",{parentName:"p"},"'"),"."),(0,p.kt)("p",null,"The use-case of a parameterized type is to kill duplications. Before:"),(0,p.kt)(s,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"// this is a tuple of 3 items, explained next\ntype intCoordinates = (int, int, int)\ntype floatCoordinates = (float, float, float)\n\nlet a: intCoordinates = (10, 20, 20)\nlet b: floatCoordinates = (10.5, 20.5, 20.5)\n")),(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-js"}),"var a = [10, 20, 20];\nvar b = [10.5, 20.5, 20.5];\n"))),(0,p.kt)("p",null,"After:"),(0,p.kt)(s,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"type coordinates<'a> = ('a, 'a, 'a)\n\nlet a: coordinates<int> = (10, 20, 20)\nlet b: coordinates<float> = (10.5, 20.5, 20.5)\n")),(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-js"}),"var a = [10, 20, 20];\nvar b = [10.5, 20.5, 20.5];\n"))),(0,p.kt)("p",null,"Note that the above codes are just contrived examples for illustration purposes. Since the types are inferred, you could have just written:"),(0,p.kt)(s,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"let buddy = (10, 20, 20)\n")),(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-js"}),"var buddy = [10, 20, 20];\n"))),(0,p.kt)("p",null,"The type system infers that it's a ",(0,p.kt)("inlineCode",{parentName:"p"},"(int, int, int)"),". Nothing else needed to be written down."),(0,p.kt)("p",null,"Type arguments appear in many places. Our ",(0,p.kt)("inlineCode",{parentName:"p"},"array<'a>")," type is such a type that requires a type parameter"),(0,p.kt)(s,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'// inferred as `array<string>`\nlet greetings = ["hello", "world", "how are you"]\n')),(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-js"}),'// inferred as `array<string>`\nvar greetings = ["hello", "world", "how are you"];\n'))),(0,p.kt)("p",null,"If types didn't accept parameters, the standard library would need to define the types ",(0,p.kt)("inlineCode",{parentName:"p"},"arrayOfString"),", ",(0,p.kt)("inlineCode",{parentName:"p"},"arrayOfInt"),", ",(0,p.kt)("inlineCode",{parentName:"p"},"arrayOfTuplesOfInt"),", etc. That'd be tedious."),(0,p.kt)("p",null,"Types can receive many arguments, and be composable."),(0,p.kt)(s,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"type result<'a, 'b> =\n  | Ok('a)\n  | Error('b)\n\ntype myPayload = {data: string}\n\ntype myPayloadResults<'errorType> = array<result<myPayload, 'errorType>>\n\nlet payloadResults: myPayloadResults<string> = [\n  Ok({data: \"hi\"}),\n  Ok({data: \"bye\"}),\n  Error(\"Something wrong happened!\")\n]\n")),(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-js"}),'var payloadResults = [\n  {\n    TAG: /* Ok */0,\n    _0: {data: "hi"}\n  },\n  {\n    TAG: /* Ok */0,\n    _0: {data: "bye"}\n  },\n  {\n    TAG: /* Error */1,\n    _0: "Something wrong happened!"\n  }\n];\n'))),(0,p.kt)("h2",o({},{id:"recursive-types"}),"Recursive Types"),(0,p.kt)("p",null,"Just like a function, a type can reference itself within itself using ",(0,p.kt)("inlineCode",{parentName:"p"},"rec"),":"),(0,p.kt)(s,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"type rec person = {\n  name: string,\n  friends: array<person>\n}\n")),(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-js"}),"// Empty output\n"))),(0,p.kt)("h2",o({},{id:"mutually-recursive-types"}),"Mutually Recursive Types"),(0,p.kt)("p",null,"Types can also be ",(0,p.kt)("em",{parentName:"p"},"mutually")," recursive through ",(0,p.kt)("inlineCode",{parentName:"p"},"and"),":"),(0,p.kt)(s,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),"type rec student = {taughtBy: teacher}\nand teacher = {students: array<student>}\n")),(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-js"}),"// Empty output\n"))),(0,p.kt)("h2",o({},{id:"type-escape-hatch"}),"Type Escape Hatch"),(0,p.kt)("p",null,"ReScript's type system is robust and does not allow dangerous, unsafe stuff like implicit type casting, randomly guessing a value's type, etc. However, out of pragmatism, we expose a single escape hatch for you to \"lie\" to the type system:"),(0,p.kt)(s,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-res"}),'external myShadyConversion: myType1 => myType2 = "%identity"\n')),(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-js"}),"// Empty output\n"))),(0,p.kt)("p",null,"This declaration converts a ",(0,p.kt)("inlineCode",{parentName:"p"},"myType1")," of your choice to ",(0,p.kt)("inlineCode",{parentName:"p"},"myType2")," of your choice. You can use it like so:"),(0,p.kt)(s,{labels:["ReScript","JS Output"],mdxType:"CodeTab"},(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-res",metastring:"example",example:!0}),'external convertToFloat : int => float = "%identity"\nlet age = 10\nlet gpa = 2.1 +. convertToFloat(age)\n')),(0,p.kt)("pre",null,(0,p.kt)("code",o({parentName:"pre"},{className:"language-js"}),"var age = 10;\nvar gpa = 2.1 + 10;\n"))),(0,p.kt)("p",null,"Obviously, do ",(0,p.kt)("strong",{parentName:"p"},"not")," abuse this feature. Use it tastefully when you're working with existing, overly dynamic JS code, for example."),(0,p.kt)("p",null,"More on externals ",(0,p.kt)("a",o({parentName:"p"},{href:"external.md"}),"here"),"."),(0,p.kt)("p",null,(0,p.kt)("strong",{parentName:"p"},"Note"),": this particular ",(0,p.kt)("inlineCode",{parentName:"p"},"external")," is the only one that isn't preceded by a ",(0,p.kt)("inlineCode",{parentName:"p"},"@")," ",(0,p.kt)("a",o({parentName:"p"},{href:"attribute.md"}),"attribute"),"."))}c.isMDXComponent=!0,c.frontmatter={title:"Type",description:"Types and type definitions in ReScript",canonical:"/docs/manual/latest/type",__ghEditHref:"https://github.com/reason-association/rescript-lang.org/blob/master/pages/docs/manual/latest/type.mdx"}},47412:function(e,t,a){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/manual/latest/type",function(){return a(1289)}])}},function(e){e.O(0,[92888,49774,40179],(function(){return t=47412,e(e.s=t);var t}));var t=e.O();_N_E=t}]);
<!DOCTYPE html><html><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css"/><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2b269719632b344a478b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2b269719632b344a478b.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/webpack-c49b9de92a7202ac2146.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework-23118dcc1b886e5b49be.js" as="script"/><link rel="preload" href="/_next/static/chunks/main-82e7c4d3c08582bd58e0.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-9e9d9ab67b4ceb7ec93b.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/docs/manual/v9.0.0/api/belt/array-2088f75d50db4c74b55f.js" as="script"/></head><body><div id="__next"><h1 id="array">Array</h1><div><p>Utililites for <code>Array</code> functions.</p></div><h3 id="note-about-index-syntax">Note about index syntax</h3><p>Code like <code>arr[0]</code> does <em>not</em> compile to JavaScript <code>arr[0]</code>. ReScript transforms the <code>[]</code> index syntax into a function: <code>Array.get(arr, 0)</code>. By default, this uses the default standard library&#x27;s <code>Array.get</code> function, which may raise an exception if the index isn&#x27;t found. If you <code>open Belt</code>, it will use the <code>Belt.Array.get</code> function which returns options instead of raising exceptions. <a href="../belt.mdx#array-access-runtime-safety">See this for more information</a>.</p><h2 id="length">length</h2><pre><code class="language-res" metastring="sig">let length: array&lt;&#x27;a&gt; =&gt; int
</code></pre><p>return the size of the array</p><pre><code class="language-res" metastring="example">// Returns 1
Belt.Array.length([&quot;test&quot;])
</code></pre><h2 id="size">size</h2><pre><code class="language-res" metastring="sig">let size: array&lt;&#x27;a&gt; =&gt; int
</code></pre><p>See Belt_Array.length</p><h2 id="get">get</h2><pre><code class="language-res" metastring="sig">let get: (array&lt;&#x27;a&gt;, int) =&gt; option&lt;&#x27;a&gt;
</code></pre><p>If <code>i &lt;= 0 &lt;= length(arr)</code> returns <code>Some(value)</code> where <code>value</code> is the item at index <code>i</code>.
If <code>i</code> is out of range returns <code>None</code></p><h2 id="getexn">getExn</h2><pre><code class="language-res" metastring="sig">let getExn: (array&lt;&#x27;a&gt;, int) =&gt; &#x27;a
</code></pre><p>Raise an exception if <code>i</code> is out of range.
Otherwise return the value at index <code>i</code> in <code>arr</code>.</p><h2 id="getunsafe">getUnsafe</h2><pre><code class="language-res" metastring="sig">let getUnsafe: (array&lt;&#x27;a&gt;, int) =&gt; &#x27;a
</code></pre><p>Unsafe</p><p>no bounds checking; this would cause type error if <code>i</code> does not stay within range</p><h2 id="getundefined">getUndefined</h2><pre><code class="language-res" metastring="sig">let getUndefined: (array&lt;&#x27;a&gt;, int) =&gt; Js.undefined&lt;&#x27;a&gt;
</code></pre><p>It does the samething in the runtime as <code>Belt_Array.getUnsafe</code> it is type safe since the return type still track whether it is in range or not</p><h2 id="set">set</h2><pre><code class="language-res" metastring="sig">let set: (array&lt;&#x27;a&gt;, int, &#x27;a) =&gt; bool
</code></pre><p><code>set(arr, n, x)</code> modifies <code>arr</code> in place; it replaces the nth element of <code>arr</code> with <code>x</code>.</p><p>Returns false means not updated due to out of range.</p><h2 id="setexn">setExn</h2><pre><code class="language-res" metastring="sig">let setExn: (array&lt;&#x27;a&gt;, int, &#x27;a) =&gt; unit
</code></pre><p><code>setExn(arr, i, x)</code> raise an exception if <code>i</code> is out of range.</p><h2 id="setunsafe">setUnsafe</h2><pre><code class="language-res" metastring="sig">let setUnsafe: (array&lt;&#x27;a&gt;, int, &#x27;a) =&gt; unit
</code></pre><h2 id="shuffleinplace">shuffleInPlace</h2><pre><code class="language-res" metastring="sig">let shuffleInPlace: array&lt;&#x27;a&gt; =&gt; unit
</code></pre><p><code>shuffleInPlace(arr)</code> randomly re-orders the items in <code>arr</code></p><h2 id="shuffle">shuffle</h2><pre><code class="language-res" metastring="sig">let shuffle: array&lt;&#x27;a&gt; =&gt; array&lt;&#x27;a&gt;
</code></pre><p>Returns a fresh array with items in original array randomly shuffled.</p><h2 id="reverseinplace">reverseInPlace</h2><pre><code class="language-res" metastring="sig">let reverseInPlace: array&lt;&#x27;a&gt; =&gt; unit
</code></pre><p><code>reverseInPlace(arr)</code> reverses items in <code>arr</code> in place.</p><pre><code class="language-res" metastring="example">let arr = [10, 11, 12, 13, 14]

let () = Belt.Array.reverseInPlace(arr)

arr == [14, 13, 12, 11, 10]
</code></pre><h2 id="reverse">reverse</h2><pre><code class="language-res" metastring="sig">let reverse: array&lt;&#x27;a&gt; =&gt; array&lt;&#x27;a&gt;
</code></pre><p><code>reverse(arr)</code> returns a fresh array with items in arr in reverse order.</p><pre><code class="language-res" metastring="example">Belt.Array.reverse([10, 11, 12, 13, 14]) == [14, 13, 12, 11, 10]
</code></pre><h2 id="makeuninitialized">makeUninitialized</h2><pre><code class="language-res" metastring="sig">let makeUninitialized: int =&gt; array&lt;Js.undefined&lt;&#x27;a&gt;&gt;
</code></pre><p><code>makeUninitialized(n)</code> creates an array of length <code>n</code> filled with the undefined value. You must specify the type of data that will eventually fill the array.</p><pre><code class="language-res" metastring="example">let arr: array&lt;Js.undefined&lt;string&gt;&gt; = Belt.Array.makeUninitialized(5)

Belt.Array.getExn(arr, 0) == Js.undefined
</code></pre><h2 id="makeuninitializedunsafe">makeUninitializedUnsafe</h2><pre><code class="language-res" metastring="sig">let makeUninitializedUnsafe: int =&gt; array&lt;&#x27;a&gt;
</code></pre><p>Unsafe</p><pre><code class="language-res" metastring="example">let arr = Belt.Array.makeUninitializedUnsafe(5)

Js.log(Belt.Array.getExn(arr, 0)) // undefined

Belt.Array.setExn(arr, 0, &quot;example&quot;)

Js.log(Belt.Array.getExn(arr, 0) == &quot;example&quot;)
</code></pre><h2 id="make">make</h2><pre><code class="language-res" metastring="sig">let make: (int, &#x27;a) =&gt; array&lt;&#x27;a&gt;
</code></pre><p><code>make(n, e)</code> return an array of size <code>n</code> filled with value <code>e</code>.
Returns an empty array when <code>n</code> is negative.</p><h2 id="range">range</h2><pre><code class="language-res" metastring="sig">let range: (int, int) =&gt; array&lt;int&gt;
</code></pre><p><code>range(start, finish)</code> create an inclusive array.</p><pre><code class="language-res" metastring="example">Belt.Array.range(0, 3) == [0, 1, 2, 3]

Belt.Array.range(3, 0) == []

Belt.Array.range(3, 3) == [3]
</code></pre><h2 id="rangeby">rangeBy</h2><pre><code class="language-res" metastring="sig">let rangeBy: (int, int, ~step: int) =&gt; array&lt;int&gt;
</code></pre><p><code>rangeBy(start, finish, ~step)</code></p><p>Returns empty array when step is 0 or negative. It also return an empty array when <code>start &gt; finish</code>.</p><pre><code class="language-res" metastring="example">Belt.Array.rangeBy(0, 10, ~step=3) == [0, 3, 6, 9]

Belt.Array.rangeBy(0, 12, ~step=3) == [0, 3, 6, 9, 12]

Belt.Array.rangeBy(33, 0, ~step=1) == []

Belt.Array.rangeBy(33, 0, ~step=-1) == []

Belt.Array.rangeBy(3, 12, ~step=-1) == []

Belt.Array.rangeBy(3, 3, ~step=0) == []

Belt.Array.rangeBy(3, 3, ~step=1) == [3]
</code></pre><h2 id="makebyu">makeByU</h2><pre><code class="language-res" metastring="sig">let makeByU: (int, (. int) =&gt; &#x27;a) =&gt; array&lt;&#x27;a&gt;
</code></pre><h2 id="makeby">makeBy</h2><pre><code class="language-res" metastring="sig">let makeBy: (int, int =&gt; &#x27;a) =&gt; array&lt;&#x27;a&gt;
</code></pre><p><code>makeBy(n, f)</code></p><p>Return an empty array when n is negative return an array of size n populated by <code>f(i)</code> start from <code>0</code> to <code>n - 1</code>.</p><pre><code class="language-res" metastring="example">Belt.Array.makeBy(5, (i) =&gt; i) == [0, 1, 2, 3, 4]

Belt.Array.makeBy(5, (i) =&gt; i * i) == [0, 1, 4, 9, 16]
</code></pre><h2 id="makebyandshuffleu">makeByAndShuffleU</h2><pre><code class="language-res" metastring="sig">let makeByAndShuffleU: (int, (. int) =&gt; &#x27;a) =&gt; array&lt;&#x27;a&gt;
</code></pre><h2 id="makebyandshuffle">makeByAndShuffle</h2><pre><code class="language-res" metastring="sig">let makeByAndShuffle: (int, int =&gt; &#x27;a) =&gt; array&lt;&#x27;a&gt;
</code></pre><p><code>makeByAndShuffle(n, f)</code></p><p>Equivalent to <code>shuffle(makeBy(n, f))</code></p><h2 id="zip">zip</h2><pre><code class="language-res" metastring="sig">let zip: (array&lt;&#x27;a&gt;, array&lt;&#x27;b&gt;) =&gt; array&lt;(&#x27;a, &#x27;b)&gt;
</code></pre><p><code>zip(a, b)</code></p><p>Create an array of pairs from corresponding elements of a and b. Stop with the shorter array.</p><pre><code class="language-res" metastring="example">Belt.Array.zip([1, 2], [3, 4, 5]) == [(1, 3), (2, 4)]
</code></pre><h2 id="zipbyu">zipByU</h2><pre><code class="language-res" metastring="sig">let zipByU: (array&lt;&#x27;a&gt;, array&lt;&#x27;b&gt;, (. &#x27;a, &#x27;b) =&gt; &#x27;c) =&gt; array&lt;&#x27;c&gt;
</code></pre><h2 id="zipby">zipBy</h2><pre><code class="language-res" metastring="sig">let zipBy: (array&lt;&#x27;a&gt;, array&lt;&#x27;b&gt;, (&#x27;a, &#x27;b) =&gt; &#x27;c) =&gt; array&lt;&#x27;c&gt;
</code></pre><p><code>zipBy(xs, ys, f)</code></p><p>Create an array by applying <code>f</code> to corresponding elements of <code>xs</code> and <code>ys</code>. Stops with shorter array.</p><p>Equivalent to <code>map(zip(xs, ys), ((a, b)) =&gt; f(a, b))</code></p><pre><code class="language-res" metastring="example">Belt.Array.zipBy([1, 2, 3], [4, 5], (a, b) =&gt; 2 * a + b) == [6, 9]
</code></pre><h2 id="unzip">unzip</h2><pre><code class="language-res" metastring="sig">let unzip: array&lt;(&#x27;a, &#x27;b)&gt; =&gt; (array&lt;&#x27;a&gt;, array&lt;&#x27;b&gt;)
</code></pre><p><code>unzip(a)</code> takes an array of pairs and creates a pair of arrays. The first array contains all the first items of the pairs; the second array contains all the second items.</p><pre><code class="language-res" metastring="example">Belt.Array.unzip([(1, 2), (3, 4)]) == ([1, 3], [2, 4])

Belt.Array.unzip([(1, 2), (3, 4), (5, 6), (7, 8)]) == ([1, 3, 5, 7], [2, 4, 6, 8])
</code></pre><h2 id="concat">concat</h2><pre><code class="language-res" metastring="sig">let concat: (array&lt;&#x27;a&gt;, array&lt;&#x27;a&gt;) =&gt; array&lt;&#x27;a&gt;
</code></pre><p><code>concat(xs, ys)</code></p><p>Returns a fresh array containing the concatenation of the arrays <code>v1</code> and <code>v2</code>;so even if <code>v1</code> or <code>v2</code> is empty; it can not be shared</p><pre><code class="language-res" metastring="example">Belt.Array.concat([1, 2, 3], [4, 5]) == [1, 2, 3, 4, 5]

Belt.Array.concat([], [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) == [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
</code></pre><h2 id="concatmany">concatMany</h2><pre><code class="language-res" metastring="sig">let concatMany: array&lt;array&lt;&#x27;a&gt;&gt; =&gt; array&lt;&#x27;a&gt;
</code></pre><p><code>concatMany(xss)</code></p><p>Returns a fresh array as the concatenation of <code>xss</code> (an array of arrays)</p><pre><code class="language-res" metastring="example">Belt.Array.concatMany([[1, 2, 3], [4, 5, 6], [7, 8]]) == [1, 2, 3, 4, 5, 6, 7, 8]
</code></pre><h2 id="slice">slice</h2><pre><code class="language-res" metastring="sig">let slice: (array&lt;&#x27;a&gt;, ~offset: int, ~len: int) =&gt; array&lt;&#x27;a&gt;
</code></pre><p><code>slice(xs, offset, len)</code> creates a new array with the len elements of <code>xs</code>
starting at <code>offset</code> for <code>offset</code> can be negative;and is evaluated as
<code>length(xs) - offset(slice, xs) - 1(1)</code> means get the last element as a
singleton array <code>slice(xs, ~-len, len)</code> will return a copy of the array if the
array does not have enough data; <code>slice</code> extracts through the end of sequence.</p><p>if <code>len</code> is negative; returns the empty array.</p><pre><code class="language-res" metastring="example">Belt.Array.slice([10, 11, 12, 13, 14, 15, 16], ~offset=2, ~len=3) == [12, 13, 14]

Belt.Array.slice([10, 11, 12, 13, 14, 15, 16], ~offset=-4, ~len=3) == [13, 14, 15]

Belt.Array.slice([10, 11, 12, 13, 14, 15, 16], ~offset=4, ~len=9) == [14, 15, 16]
</code></pre><h2 id="slicetoend">sliceToEnd</h2><pre><code class="language-res" metastring="sig">let sliceToEnd: (array&lt;&#x27;a&gt;, int) =&gt; array&lt;&#x27;a&gt;
</code></pre><p><code>sliceToEnd(xs, offset)</code> creates a new array with the elements of <code>xs</code> starting at <code>offset</code></p><p><code>offset</code> can be negative; and is evaluated as <code>length(xs) - offset(sliceToEnd, xs) - 1</code> means get the last element as a singleton array</p><p><code>sliceToEnd(xs, 0)</code> will return a copy of the array</p><pre><code class="language-res" metastring="example">Belt.Array.sliceToEnd([10, 11, 12, 13, 14, 15, 16], 2) == [12, 13, 14, 15, 16]

Belt.Array.sliceToEnd([10, 11, 12, 13, 14, 15, 16], -4) == [13, 14, 15, 16]
</code></pre><h2 id="copy">copy</h2><pre><code class="language-res" metastring="sig">let copy: array&lt;&#x27;a&gt; =&gt; array&lt;&#x27;a&gt;
</code></pre><p><code>copy(a)</code></p><p>Returns a copy of a; that is; a fresh array containing the same elements as a.</p><h2 id="fill">fill</h2><pre><code class="language-res" metastring="sig">let fill: (array&lt;&#x27;a&gt;, ~offset: int, ~len: int, &#x27;a) =&gt; unit
</code></pre><p><code>fill(arr, ~offset, ~len, x)</code></p><p>Modifies <code>arr</code> in place, storing <code>x</code> in elements number <code>offset</code> to <code>offset + len - 1</code>.
<code>offset</code> can be negative; and is evaluated as <code>length(arr - offset)</code></p><p><code>fill(arr, ~offset=-1, ~len=1)</code> means fill the last element, if the array does not have enough data; <code>fill</code> will ignore it</p><pre><code class="language-res" metastring="example">let arr = Belt.Array.makeBy(5, (i) =&gt; i)

Belt.Array.fill(arr, ~offset=2, ~len=2, 9)

arr == [0, 1, 9, 9, 4]

Belt.Array.fill(arr, ~offset=7, ~len=2, 8)

arr == [0, 1, 9, 9, 4]
</code></pre><h2 id="blit">blit</h2><pre><code class="language-res" metastring="sig">let blit:
  (
    ~src: array&lt;&#x27;a&gt;,
    ~srcOffset: int,
    ~dst: array&lt;&#x27;a&gt;,
    ~dstOffset: int,
    ~len: int
  ) =&gt;
  unit
</code></pre><p><code>blit(~src=v1, ~srcOffset=o1, ~dst=v2, ~dstOffset=o2, ~len)</code></p><p>copies <code>len</code> elements from array <code>v1</code>;starting at element number <code>o1</code>;to array <code>v2</code>, starting at element number <code>o2</code>.</p><p>It works correctly even if <code>v1</code> and <code>v2</code> are the same array;and the source and destination chunks overlap.</p><p><code>offset</code> can be negative; <code>-1</code> means <code>len - 1</code>; if <code>len + offset</code> is still negative;it will be set as 0</p><p>For each of the examples;presume that <code>v1 == [10, 11, 12, 13, 14, 15, 16, 17]</code> and <code>v2 == [20, 21, 22, 23, 24, 25, 26, 27]</code>. The result shown is the content of the destination array.</p><pre><code class="language-res" metastring="example">let v1 = [10, 11, 12, 13, 14, 15, 16, 17]
let v2 = [20, 21, 22, 23, 24, 25, 26, 27]

Belt.Array.blit(~src=v1, ~srcOffset=4, ~dst=v2, ~dstOffset=2, ~len=3)
v2 == [20, 21, 14, 15, 16, 25, 26, 27]

Belt.Array.blit(~src=v1, ~srcOffset=4, ~dst=v1, ~dstOffset=2, ~len=3)
v1 == [10, 11, 14, 15, 16, 15, 16, 17]
</code></pre><h2 id="blitunsafe">blitUnsafe</h2><pre><code class="language-res" metastring="sig">let blitUnsafe: (~src: array&lt;&#x27;a&gt;, ~srcOffset: int, ~dst: array&lt;&#x27;a&gt;, ~dstOffset: int, ~len: int) =&gt; unit
</code></pre><p>Unsafe blit without bounds checking.</p><h2 id="foreachu">forEachU</h2><pre><code class="language-res" metastring="sig">let forEachU: (array&lt;&#x27;a&gt;, (. &#x27;a) =&gt; unit) =&gt; unit
</code></pre><h2 id="foreach">forEach</h2><pre><code class="language-res" metastring="sig">let forEach: (array&lt;&#x27;a&gt;, &#x27;a =&gt; unit) =&gt; unit
</code></pre><p><code>forEach(xs, f)</code></p><p>Call <code>f</code> on each element of <code>xs</code> from the beginning to end. <code>f</code> returns <code>unit</code>;so no new array is created. Use <code>forEach</code> when you are primarily concerned with repetitively creating side effects.</p><pre><code class="language-res" metastring="example">Belt.Array.forEach([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], x =&gt; Js.log(&quot;Item: &quot; ++ x))

/*
  prints:
  Item: a
  Item: b
  Item: c
*/
let total = ref(0)

Belt.Array.forEach([1, 2, 3, 4], x =&gt; total := total.contents + x)

total.contents == 1 + 2 + 3 + 4
</code></pre><h2 id="mapu">mapU</h2><pre><code class="language-res" metastring="sig">let mapU: (array&lt;&#x27;a&gt;, (. &#x27;a) =&gt; &#x27;b) =&gt; array&lt;&#x27;b&gt;
</code></pre><h2 id="map">map</h2><pre><code class="language-res" metastring="sig">let map: (array&lt;&#x27;a&gt;, &#x27;a =&gt; &#x27;b) =&gt; array&lt;&#x27;b&gt;
</code></pre><p><code>map(xs, f)</code></p><p>Returns a new array by calling <code>f</code> for each element of <code>xs</code> from the beginning to end.</p><pre><code class="language-res" metastring="example">Belt.Array.map([1, 2], (x) =&gt; x + 1) == [3, 4]
</code></pre><h2 id="getbyu">getByU</h2><pre><code class="language-res" metastring="sig">let getByU: (array&lt;&#x27;a&gt;, (. &#x27;a) =&gt; bool) =&gt; option&lt;&#x27;a&gt;
</code></pre><h2 id="getby">getBy</h2><pre><code class="language-res" metastring="sig">let getBy: (array&lt;&#x27;a&gt;, &#x27;a =&gt; bool) =&gt; option&lt;&#x27;a&gt;
</code></pre><p><code>getBy(xs, p)</code></p><p>Returns <code>Some(value)</code> for the first value in <code>xs</code> that satisifies the predicate function <code>p</code>; returns <code>None</code> if no element satisifies the function.</p><pre><code class="language-res" metastring="example">Belt.Array.getBy([1, 4, 3, 2], (x) =&gt; mod(x, 2) == 0) == Some(4)
Belt.Array.getBy([15, 13, 11], (x) =&gt; mod(x, 2) == 0) == None
</code></pre><h2 id="getindexbyu">getIndexByU</h2><pre><code class="language-res" metastring="sig">let getIndexByU: (array&lt;&#x27;a&gt;, (. &#x27;a) =&gt; bool) =&gt; option&lt;int&gt;
</code></pre><h2 id="getindexby">getIndexBy</h2><pre><code class="language-res" metastring="sig">let getIndexBy: (array&lt;&#x27;a&gt;, &#x27;a =&gt; bool) =&gt; option&lt;int&gt;
</code></pre><p><code>getIndexBy(xs, p)</code></p><p>returns <code>Some(index)</code> for the first value in <code>xs</code> that satisifies the predicate function <code>p</code>;
returns <code>None</code> if no element satisifies the function.</p><pre><code class="language-res" metastring="example">Belt.Array.getIndexBy([1, 4, 3, 2], (x) =&gt; mod(x, 2) == 0) == Some(1)
Belt.Array.getIndexBy([15, 13, 11], (x) =&gt; mod(x, 2) == 0) == None
</code></pre><h2 id="keepu">keepU</h2><pre><code class="language-res" metastring="sig">let keepU: (array&lt;&#x27;a&gt;, (. &#x27;a) =&gt; bool) =&gt; array&lt;&#x27;a&gt;
</code></pre><h2 id="keep">keep</h2><pre><code class="language-res" metastring="sig">let keep: (array&lt;&#x27;a&gt;, &#x27;a =&gt; bool) =&gt; array&lt;&#x27;a&gt;
</code></pre><p><code>keep(xs, p)</code></p><p>Returns a new array that keep all elements satisfy <code>p</code>.</p><pre><code class="language-res" metastring="example">Belt.Array.keep([1, 2, 3], (x) =&gt; mod(x, 2) == 0) == [2]
</code></pre><h2 id="keepwithindexu">keepWithIndexU</h2><pre><code class="language-res" metastring="sig">let keepWithIndexU: (array&lt;&#x27;a&gt;, (. &#x27;a, int) =&gt; bool) =&gt; array&lt;&#x27;a&gt;
</code></pre><h2 id="keepwithindex">keepWithIndex</h2><pre><code class="language-res" metastring="sig">let keepWithIndex: (array&lt;&#x27;a&gt;, (&#x27;a, int) =&gt; bool) =&gt; array&lt;&#x27;a&gt;
</code></pre><p><code>keepWithIndex(xs, p)</code></p><p>Returns a new array that keep all elements satisfy <code>p</code>.</p><pre><code class="language-res" metastring="example">Belt.Array.keepWithIndex([1, 2, 3], (_x, i) =&gt; i == 1) == [2]
</code></pre><h2 id="keepmapu">keepMapU</h2><pre><code class="language-res" metastring="sig">let keepMapU: (array&lt;&#x27;a&gt;, (. &#x27;a) =&gt; option&lt;&#x27;b&gt;) =&gt; array&lt;&#x27;b&gt;
</code></pre><h2 id="keepmap">keepMap</h2><pre><code class="language-res" metastring="sig">let keepMap: (array&lt;&#x27;a&gt;, &#x27;a =&gt; option&lt;&#x27;b&gt;) =&gt; array&lt;&#x27;b&gt;
</code></pre><p><code>keepMap(xs, p)</code></p><p>Returns a new array that keep all elements that return a non-None applied <code>p</code>.</p><pre><code class="language-res" metastring="example">Belt.Array.keepMap([1, 2, 3], x =&gt;
  if mod(x, 2) == 0 {
    Some(x)
  } else {
    None
  }
)
== [2]
</code></pre><h2 id="foreachwithindexu">forEachWithIndexU</h2><pre><code class="language-res" metastring="sig">let forEachWithIndexU: (array&lt;&#x27;a&gt;, (. int, &#x27;a) =&gt; unit) =&gt; unit
</code></pre><h2 id="foreachwithindex">forEachWithIndex</h2><pre><code class="language-res" metastring="sig">let forEachWithIndex: (array&lt;&#x27;a&gt;, (int, &#x27;a) =&gt; unit) =&gt; unit
</code></pre><p><code>forEachWithIndex(xs, f)</code></p><p>The same as <code>Belt_Array.forEach</code>;
except that <code>f</code> is supplied two arguments: the index starting from 0 and the element from <code>xs</code>.</p><pre><code class="language-res" metastring="example">Belt.Array.forEachWithIndex([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], (i, x) =&gt; Js.log(&quot;Item &quot; ++ Belt.Int.toString(i) ++ &quot; is &quot; ++ x))

/*
  prints:
  Item 0 is a
  Item 1 is b
  Item 2 is cc
*/
let total = ref(0)

Belt.Array.forEachWithIndex([10, 11, 12, 13], (i, x) =&gt; total := total.contents + x + i)

total.contents == 0 + 10 + 1 + 11 + 2 + 12 + 3 + 13
</code></pre><h2 id="mapwithindexu">mapWithIndexU</h2><pre><code class="language-res" metastring="sig">let mapWithIndexU: (array&lt;&#x27;a&gt;, (. int, &#x27;a) =&gt; &#x27;b) =&gt; array&lt;&#x27;b&gt;
</code></pre><h2 id="mapwithindex">mapWithIndex</h2><pre><code class="language-res" metastring="sig">let mapWithIndex: (array&lt;&#x27;a&gt;, (int, &#x27;a) =&gt; &#x27;b) =&gt; array&lt;&#x27;b&gt;
</code></pre><p><code>mapWithIndex(xs, f)</code></p><p><code>mapWithIndex(xs, f)</code> applies <code>f</code> to each element of <code>xs</code>. Function <code>f</code> takes two arguments: the index starting from 0 and the element from <code>xs</code>.</p><pre><code class="language-res" metastring="example">Belt.Array.mapWithIndex([1, 2, 3], (i, x) =&gt; i + x) == [0 + 1, 1 + 2, 2 + 3]
</code></pre><h2 id="partitionu">partitionU</h2><pre><code class="language-res" metastring="sig">let partitionU: (array&lt;&#x27;a&gt;, (. &#x27;a) =&gt; bool) =&gt; (array&lt;&#x27;a&gt;, array&lt;&#x27;a&gt;)
</code></pre><h2 id="partition">partition</h2><pre><code class="language-res" metastring="sig">let partition: (array&lt;&#x27;a&gt;, &#x27;a =&gt; bool) =&gt; (array&lt;&#x27;a&gt;, array&lt;&#x27;a&gt;)
</code></pre><p><code>partition(f, a)</code> split array into tuple of two arrays based on predicate <code>f</code>; first of tuple where predicate cause true, second where predicate cause false</p><pre><code class="language-res" metastring="example">Belt.Array.partition([1, 2, 3, 4, 5], (x) =&gt; mod(x, 2) == 0) == ([2, 4], [1, 3, 5])

Belt.Array.partition([1, 2, 3, 4, 5], (x) =&gt; mod(x, 2) != 0) == ([1, 3, 5], [2, 4])
</code></pre><h2 id="reduceu">reduceU</h2><pre><code class="language-res" metastring="sig">let reduceU: (array&lt;&#x27;b&gt;, &#x27;a, (. &#x27;a, &#x27;b) =&gt; &#x27;a) =&gt; &#x27;a
</code></pre><h2 id="reduce">reduce</h2><pre><code class="language-res" metastring="sig">let reduce: (array&lt;&#x27;b&gt;, &#x27;a, (&#x27;a, &#x27;b) =&gt; &#x27;a) =&gt; &#x27;a
</code></pre><p><code>reduce(xs, init, f)</code></p><p>Applies <code>f</code> to each element of <code>xs</code> from beginning to end. Function <code>f</code> has two parameters: the item from the list and an “accumulator”; which starts with a value of <code>init</code>. <code>reduce</code> returns the final value of the accumulator.</p><pre><code class="language-res" metastring="example">Belt.Array.reduce([2, 3, 4], 1, (a, b) =&gt; a + b) == 10

Belt.Array.reduce([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;], &quot;&quot;, (a, b) =&gt; a ++ b) == &quot;abcd&quot;
</code></pre><h2 id="reducereverseu">reduceReverseU</h2><pre><code class="language-res" metastring="sig">let reduceReverseU: (array&lt;&#x27;b&gt;, &#x27;a, (. &#x27;a, &#x27;b) =&gt; &#x27;a) =&gt; &#x27;a
</code></pre><h2 id="reducereverse">reduceReverse</h2><pre><code class="language-res" metastring="sig">let reduceReverse: (array&lt;&#x27;b&gt;, &#x27;a, (&#x27;a, &#x27;b) =&gt; &#x27;a) =&gt; &#x27;a
</code></pre><p><code>reduceReverse(xs, init, f)</code></p><p>Works like <code>Belt_Array.reduce</code>; except that function <code>f</code> is applied to each item of <code>xs</code> from the last back to the first.</p><pre><code class="language-res" metastring="example">Belt.Array.reduceReverse([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;], &quot;&quot;, (a, b) =&gt; a ++ b) == &quot;dcba&quot;
</code></pre><h2 id="reducereverse2u">reduceReverse2U</h2><pre><code class="language-res" metastring="sig">let reduceReverse2U: (array&lt;&#x27;a&gt;, array&lt;&#x27;b&gt;, &#x27;c, (. &#x27;c, &#x27;a, &#x27;b) =&gt; &#x27;c) =&gt; &#x27;c
</code></pre><h2 id="reducereverse2">reduceReverse2</h2><pre><code class="language-res" metastring="sig">let reduceReverse2: (array&lt;&#x27;a&gt;, array&lt;&#x27;b&gt;, &#x27;c, (&#x27;c, &#x27;a, &#x27;b) =&gt; &#x27;c) =&gt; &#x27;c
</code></pre><p><code>reduceReverse2(xs, ys, init, f)</code></p><p>Reduces two arrays xs and ys;taking items starting at <code>min(length(xs), length(ys))</code> down to and including zero.</p><pre><code class="language-res" metastring="example">Belt.Array.reduceReverse2([1, 2, 3], [1, 2], 0, (acc, x, y) =&gt; acc + x + y) == 6
</code></pre><h2 id="reducewithindexu">reduceWithIndexU</h2><pre><code class="language-res" metastring="sig">let reduceWithIndexU: (array&lt;&#x27;a&gt;, &#x27;b, (. &#x27;b, &#x27;a, int) =&gt; &#x27;b) =&gt; &#x27;b
</code></pre><h2 id="reducewithindex">reduceWithIndex</h2><pre><code class="language-res" metastring="sig">let reduceWithIndex: (array&lt;&#x27;a&gt;, &#x27;b, (&#x27;b, &#x27;a, int) =&gt; &#x27;b) =&gt; &#x27;b
</code></pre><p><code>reduceWithIndex(xs, f)</code></p><p>Applies <code>f</code> to each element of <code>xs</code> from beginning to end. Function <code>f</code> has three parameters: the item from the array and an “accumulator”, which starts with a value of <code>init</code> and the index of each element. <code>reduceWithIndex</code> returns the final value of the accumulator.</p><pre><code class="language-res" metastring="example">Belt.Array.reduceWithIndex([1, 2, 3, 4], 0, (acc, x, i) =&gt; acc + x + i) == 16
</code></pre><h2 id="someu">someU</h2><pre><code class="language-res" metastring="sig">let someU: (array&lt;&#x27;a&gt;, (. &#x27;a) =&gt; bool) =&gt; bool
</code></pre><h2 id="some">some</h2><pre><code class="language-res" metastring="sig">let some: (array&lt;&#x27;a&gt;, &#x27;a =&gt; bool) =&gt; bool
</code></pre><p><code>some(xs, p)</code></p><p>Returns true if at least one of the elements in <code>xs</code> satifies <code>p</code>; where <code>p</code> is a predicate: a function taking an element and returning a <code>bool</code>.</p><pre><code class="language-res" metastring="example">Belt.Array.some([2, 3, 4], (x) =&gt; mod(x, 2) == 1) == true

Belt.Array.some([(-1), (-3), (-5)], (x) =&gt; x &gt; 0) == false
</code></pre><h2 id="everyu">everyU</h2><pre><code class="language-res" metastring="sig">let everyU: (array&lt;&#x27;a&gt;, (. &#x27;a) =&gt; bool) =&gt; bool
</code></pre><h2 id="every">every</h2><pre><code class="language-res" metastring="sig">let every: (array&lt;&#x27;a&gt;, &#x27;a =&gt; bool) =&gt; bool
</code></pre><p><code>every(xs, p)</code></p><p>Returns <code>true</code> if all elements satisfy <code>p</code>; where <code>p</code> is a predicate: a function taking an element and returning a <code>bool</code>.</p><pre><code class="language-res" metastring="example">Belt.Array.every([1, 3, 5], (x) =&gt; mod(x, 2) == 1) == true

Belt.Array.every([1, (-3), 5], (x) =&gt; x &gt; 0) == false
</code></pre><h2 id="every2u">every2U</h2><pre><code class="language-res" metastring="sig">let every2U: (array&lt;&#x27;a&gt;, array&lt;&#x27;b&gt;, (. &#x27;a, &#x27;b) =&gt; bool) =&gt; bool
</code></pre><h2 id="every2">every2</h2><pre><code class="language-res" metastring="sig">let every2: (array&lt;&#x27;a&gt;, array&lt;&#x27;b&gt;, (&#x27;a, &#x27;b) =&gt; bool) =&gt; bool
</code></pre><p><code>every2(xs, ys, p)</code></p><p>returns true if <code>p(xi, yi)</code> is true for all pairs of elements up to the shorter length (i.e. <code>min(length(xs), length(ys))</code>)</p><pre><code class="language-res" metastring="example">Belt.Array.every2([1, 2, 3], [0, 1], (a, b) =&gt; a &gt; b) == true

Belt.Array.every2([], [1], (x, y) =&gt; x &gt; y) == true

Belt.Array.every2([2, 3], [1], (x, y) =&gt; x &gt; y) == true

Belt.Array.every2([0, 1], [5, 0], (x, y) =&gt; x &gt; y) == false
</code></pre><h2 id="some2u">some2U</h2><pre><code class="language-res" metastring="sig">let some2U: (array&lt;&#x27;a&gt;, array&lt;&#x27;b&gt;, (. &#x27;a, &#x27;b) =&gt; bool) =&gt; bool
</code></pre><h2 id="some2">some2</h2><pre><code class="language-res" metastring="sig">let some2: (array&lt;&#x27;a&gt;, array&lt;&#x27;b&gt;, (&#x27;a, &#x27;b) =&gt; bool) =&gt; bool
</code></pre><p><code>some2(xs, ys, p)</code></p><p>returns true if <code>p(xi, yi)</code> is true for any pair of elements up to the shorter length (i.e. <code>min(length(xs), length(ys))</code>)</p><pre><code class="language-res" metastring="example">Belt.Array.some2([0, 2], [1, 0, 3], (a, b) =&gt; a &gt; b) == true

Belt.Array.some2([], [1], (x, y) =&gt; x &gt; y) == false

Belt.Array.some2([2, 3], [1, 4], (x, y) =&gt; x &gt; y) == true
</code></pre><h2 id="cmpu">cmpU</h2><pre><code class="language-res" metastring="sig">let cmpU: (array&lt;&#x27;a&gt;, array&lt;&#x27;a&gt;, (. &#x27;a, &#x27;a) =&gt; int) =&gt; int
</code></pre><h2 id="cmp">cmp</h2><pre><code class="language-res" metastring="sig">let cmp: (array&lt;&#x27;a&gt;, array&lt;&#x27;a&gt;, (&#x27;a, &#x27;a) =&gt; int) =&gt; int
</code></pre><p><code>cmp(xs, ys, f)</code></p><p>Compared by length if <code>length(xs) != length(ys)</code>; returning -1 if <code>length(xs) &lt; length(ys)</code> or 1 if <code>length(xs) &gt; length(ys)</code>
Otherwise compare one by one <code>f(x, y)</code>. <code>f</code> returns
a negative number if <code>x</code> is “less than” <code>y</code>
zero if <code>x</code> is “equal to” <code>y</code>
a positive number if <code>x</code> is “greater than” <code>y</code>
The comparison returns the first non-zero result of <code>f</code>;or zero if <code>f</code> returns zero for all <code>x</code> and <code>y</code>.</p><pre><code class="language-res" metastring="example">Belt.Array.cmp([1, 3, 5], [1, 4, 2], (a, b) =&gt; compare(a, b)) == -1

Belt.Array.cmp([1, 3, 5], [1, 2, 3], (a, b) =&gt; compare(a, b)) == 1

Belt.Array.cmp([1, 3, 5], [1, 3, 5], (a, b) =&gt; compare(a, b)) == 0
</code></pre><h2 id="equ">eqU</h2><pre><code class="language-res" metastring="sig">let eqU: (array&lt;&#x27;a&gt;, array&lt;&#x27;a&gt;, (. &#x27;a, &#x27;a) =&gt; bool) =&gt; bool
</code></pre><h2 id="eq">eq</h2><pre><code class="language-res" metastring="sig">let eq: (array&lt;&#x27;a&gt;, array&lt;&#x27;a&gt;, (&#x27;a, &#x27;a) =&gt; bool) =&gt; bool
</code></pre><p><code>eq(xs, ys)</code></p><p>return false if length is not the same
otherwise compare items one by one using <code>f(xi, yi)</code>; and return true if all results are truefalse otherwise</p><pre><code class="language-res" metastring="example">Belt.Array.eq([1, 2, 3], [(-1), (-2), (-3)], (a, b) =&gt; abs(a) == abs(b)) == true
</code></pre><h2 id="truncatetolengthunsafe">truncateToLengthUnsafe</h2><pre><code class="language-res" metastring="sig">let truncateToLengthUnsafe: (array&lt;&#x27;a&gt;, int) =&gt; unit
</code></pre><p>Unsafe <code>truncateToLengthUnsafe(xs, n)</code> sets length of array <code>xs</code> to <code>n</code>.</p><p>If <code>n</code> is greater than the length of <code>xs</code>; the extra elements are set to <code>Js.Null_undefined.null</code>.</p><p>If <code>n</code> is less than zero; raises a <code>RangeError</code>.</p><pre><code class="language-res" metastring="example">let arr = [&quot;ant&quot;, &quot;bee&quot;, &quot;cat&quot;, &quot;dog&quot;, &quot;elk&quot;]

Belt.Array.truncateToLengthUnsafe(arr, 3)

arr == [&quot;ant&quot;, &quot;bee&quot;, &quot;cat&quot;]
</code></pre></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/docs/manual/v9.0.0/api/belt/array","query":{},"buildId":"57i003GrurB9OA8mdo-dW","runtimeConfig":{},"nextExport":true,"autoExport":true,"isFallback":false}</script><script nomodule="" src="/_next/static/chunks/polyfills-9def993fe817cc057038.js"></script><script src="/_next/static/chunks/webpack-c49b9de92a7202ac2146.js" async=""></script><script src="/_next/static/chunks/framework-23118dcc1b886e5b49be.js" async=""></script><script src="/_next/static/chunks/main-82e7c4d3c08582bd58e0.js" async=""></script><script src="/_next/static/chunks/pages/_app-9e9d9ab67b4ceb7ec93b.js" async=""></script><script src="/_next/static/chunks/pages/docs/manual/v9.0.0/api/belt/array-2088f75d50db4c74b55f.js" async=""></script><script src="/_next/static/57i003GrurB9OA8mdo-dW/_buildManifest.js" async=""></script><script src="/_next/static/57i003GrurB9OA8mdo-dW/_ssgManifest.js" async=""></script><script async="" defer="" src="https://scripts.simpleanalyticscdn.com/latest.js"></script><noscript><img src="https://queue.simpleanalyticscdn.com/noscript.gif" alt=""/></noscript></body></html>
---
title: "å¤šæ€å˜ä½“"
description: "The Polymorphic Variant data structure in ReScript"
canonical: "/docs/manual/latest/polymorphic-variant"
---
<!-- 
# Polymorphic Variant
-->
# å¤šæ€å˜ä½“

<!-- 
Polymorphic variants (or poly variant) are a cousin of [variant](variant). With these differences:
-->
å¤šæ€å˜ä½“æ˜¯[å˜ä½“](variant)çš„è¡¨äº²ï¼Œä¸»è¦æœ‰ä»¥ä¸‹ä¸åŒï¼š
<!-- 
- They start with a `#` and the constructor name doesn't need to be capitalized.
- They don't require an explicit type definition. The type is inferred from usage.
- Values of different poly variant types can share the constructors they have in common (aka, poly variants are "structurally" typed, as opposed to ["nominally" typed](variant#variant-types-are-found-by-field-name)).
-->
- å¤šæ€å˜ä½“ç”±`#`å¼€å¤´ï¼Œå¹¶ä¸”æ„é€ å™¨çš„åå­—ä¸å¿…è¦å¤§å†™ã€‚
- å¤šæ€å˜ä½“ä¸éœ€è¦ä¸€ä¸ªæ˜¾å¼çš„ç±»å‹å£°æ˜ï¼Œç±»å‹é€šè¿‡ä½¿ç”¨æƒ…å†µæ¨å¯¼ã€‚
- ä¸åŒçš„å¤šæ€å˜ä½“å¯ä»¥å…±äº«å®ƒä»¬å…±æœ‰çš„æ„é€ å™¨(æ¢å¥è¯æ¥è¯´ï¼Œå¤šæ€å˜ä½“æ˜¯"ç»“æ„åŒ–"ç±»å‹ï¼Œä¸[åä¹‰ç±»å‹(nominally typed)](variant#variant-types-are-found-by-field-name)ç›¸å)
<!-- 
They're a convenient and useful alternative to regular variants, but should **not** be abused. See the drawbacks at the end of this page.
-->

å®ƒä»¬æ˜¯å¸¸è§„å˜ä½“çš„ä¸€ä¸ªæ–¹ä¾¿å’Œæœ‰ç”¨çš„æ›¿ä»£ç‰©ï¼Œä½†**ä¸åº”è¯¥**è¢«æ»¥ç”¨ï¼Œè¯·åœ¨æœ¬é¡µæœ«å°¾çš„æŸ¥çœ‹å®ƒä»¬ç¼ºç‚¹ã€‚
<!-- 
## Creation 
-->
## åˆ›å»ºå¤šæ€å˜ä½“
<!-- 
We provide 3 syntaxes for a poly variant's constructor:
-->

ReScriptæä¾›äº†ä¸‰ç§è¯­æ³•åˆ›å»ºä¸€ä¸ªå¤šæ€å˜ä½“çš„æ„é€ å™¨ï¼š

<CodeTab labels={["ReScript", "JS Output"]}>

```res
let myColor = #red
let myLabel = #"aria-hidden"
let myNumber = #7
```

```js
var myColor = "red";
var myLabel = "aria-hidden";
var myNumber = 7;
```

</CodeTab>

<div class="hidden">
**Take a look at the output**. Poly variants are _great_ for JavaScript interop. For example, you can use it to model JavaScript string and number enums like TypeScript, but without confusing their accidental usage with regular strings and numbers.
</div>

**æ£€æŸ¥ä¸€ä¸‹ JS çš„ç¼–è¯‘ç»“æœ**. å¤šæ€å˜ä½“å¯¹ JavaScript äº’æ“ä½œæ˜¯**å¾ˆæœ‰ç”¨çš„**. ä¾‹å¦‚ï¼Œä½ å¯ä»¥ç”¨å®ƒæ¥ä¸º JavaScript çš„å­—ç¬¦ä¸²å’Œæ•°å­—æšä¸¾å»ºæ¨¡ï¼Œå°±åƒ TypeScript ä¸€æ ·ï¼Œä½†ä¸ä¼šæ„å¤–æŠŠå®ƒä»¬ä¸æ™®é€šçš„å­—ç¬¦ä¸²å’Œæ•°å­—ææ··ã€‚
<!-- 
`myColor` uses the common syntax. The second and third syntaxes are to support expressing strings and numbers more conveniently. We allow the second one because otherwise it'd be invalid syntax since symbols like `-` and others are usually reserved.
-->
`myColor`çš„å®šä¹‰ä½¿ç”¨çš„æ˜¯æ™®é€šè¯­æ³•ã€‚ç¬¬äºŒå’Œç¬¬ä¸‰ç§è¯­æ³•æ˜¯ä¸ºäº†æ”¯æŒæ›´æ–¹ä¾¿åœ°è¡¨è¾¾å­—ç¬¦ä¸²å’Œæ•°å­—ã€‚æˆ‘ä»¬å…è®¸ç¬¬äºŒç§è¯­æ³•ï¼Œå¦åˆ™å®šä¹‰åŒåå˜ä½“å°†æ˜¯æ— æ•ˆçš„è¯­æ³•ï¼Œå› ä¸ºåƒ`-`å’Œå…¶ä»–ç¬¦å·é€šå¸¸æ˜¯ä¿ç•™çš„ã€‚

<!-- 
## Type Declaration 
-->
# ç±»å‹å£°æ˜
<!-- 
Although **optional**, you can still pre-declare a poly variant type:
-->
å°½ç®¡æ˜¯**å¯é€‰çš„**, ä½ ä»ç„¶å¯ä»¥é¢„å…ˆå®šä¹‰ä¸€ä¸ªå¤šæ€å˜ä½“ç±»å‹ï¼š

```res
// Note the surrounding square brackets, and # for constructors
// æ³¨æ„ä¸‹é¢çš„æ–¹æ‹¬å·å’Œæ„é€ å™¨å‰é¢çš„ #
type color = [#red | #green | #blue]
```
<!-- 
These types can also be inlined, unlike for regular variant:
-->
ä¸åƒä¸€èˆ¬çš„å˜ä½“ï¼Œè¿™äº›ç±»å‹æ˜¯å¯ä»¥è¢«å†…è”çš„ï¼š

<CodeTab labels={["ReScript", "JS Output"]}>

```res
let render = (myColor: [#red | #green | #blue]) => {
  switch myColor {
  | #blue => Js.log("Hello blue!")
  | #red
  | #green => Js.log("Hello other colors")
  }
}
```

```js
function render(myColor) {
  if (myColor === "green" || myColor === "red") {
    console.log("Hello other colors");
  } else {
    console.log("Hello blue!");
  }
}
```

</CodeTab>

<!-- 
**Note**: because a poly variant value's type definition is **inferred** and not searched in the scope, the following snippet won't error:
-->
**æ³¨æ„**: å› ä¸ºå¤šæ€å˜ä½“çš„å€¼æ˜¯è¢«**æ¨å¯¼**çš„ï¼Œå¹¶ä¸”ä¸éœ€è¦å†ä½œç”¨åŸŸä¸­æœç´¢ç±»å‹å®šä¹‰ï¼Œæ‰€ä»¥ä¸‹åˆ—çš„ä»£ç ç‰‡æ®µå¹¶ä¸ä¼šæŠ¥é”™ï¼š

<CodeTab labels={["ReScript", "JS Output"]}>

```res
type color = [#red | #green | #blue]

let render = myColor => {
  switch myColor {
  | #blue => Js.log("Hello blue!")
  | #green => Js.log("Hello green!")
  // works!
  | #yellow => Js.log("Hello yellow!")
  }
}
```

```js
function render(myColor) {
  if (myColor === "yellow") {
    console.log("Hello yellow!");
  } else if (myColor === "green") {
    console.log("Hello green!");
  } else {
    console.log("Hello blue!");
  }
}
```

</CodeTab>

<!-- 
That `myColor` parameter's type is inferred to be `#red`, `#green` or `#yellow`, and is unrelated to the `color` type. If you intended `myColor` to be of type `color`, annotate it as `myColor: color` in any of the places.
-->

ç»è¿‡ç±»å‹æ¨å¯¼åï¼Œ`myColor`å‚æ•°çš„ç±»å‹ä¼šæ˜¯ `#red`, `#green`æˆ–è€…`#yellow`, å¹¶ä¸”ä¸`color`ç±»å‹æ— å…³ã€‚å¦‚æœä½ æ‰§æ„è¦ç”¨è®©`myColor`çš„ç±»å‹æ˜¯`color`, åœ¨å…¶å‡ºç°å¤„ç»™å®ƒä¸€ä¸ªåƒ`myColor: color`è¿™æ ·çš„ç±»å‹ç­¾åï¼š
<!-- 
## Constructor Arguments 
-->
## æ„é€ å™¨å‚æ•°
<!-- 
This is similar to a regular variant's [constructor arguments](variant#constructor-arguments):
-->

è¿™å’Œ[å¸¸è§„çš„å˜ä½“](variant#constructor-arguments)ç±»ä¼¼ï¼š

<CodeTab labels={["ReScript", "JS Output"]}>

```res
type account = [
  | #Anonymous
  | #Instagram(string)
  | #Facebook(string, int)
]

let me: account = #Instagram("Jenny")
let him: account = #Facebook("Josh", 26)
```

```js
var me = {
  NAME: "Instagram",
  VAL: "Jenny"
};

var him = {
  NAME: "Facebook",
  VAL: [
    "Josh",
    26
  ]
};
```

</CodeTab>

<!-- 
### Combine Types and Pattern Match 
-->
### æŠŠç±»å‹å’Œæ¨¡å¼åŒ¹é…ç»“åˆ

You can use poly variant types within other poly variant types to create a sum of all constructors:

ä½ å¯ä»¥åœ¨å¤šæ€å˜ä½“ç±»å‹ä¸­ä½¿ç”¨å…¶ä»–å¤šå˜ä½“ç±»å‹æ¥åˆ›å»ºä¸€ä¸ªæ‰€æœ‰æ„é€ ä½“çš„æ€»å’Œ(sum).

<CodeTab labels={["ReScript", "JS Output"]}>

```res
type red = [#Ruby | #Redwood | #Rust]
type blue = [#Sapphire | #Neon | #Navy]

// Contains all constructors of red and blue.
// Also adds #Papayawhip
// ç±»å‹ color ä¼šåŒ…å«redå’Œ blue æ‰€æœ‰çš„æ„é€ å™¨ï¼Œè¿˜ä¼šåŠ ä¸Š#Papayawhip

type color = [red | blue | #Papayawhip]

let myColor: color = #Ruby
```

```js
var myColor = "Ruby";
```

</CodeTab>

<!-- 
There's also some special [pattern matching](./pattern-matching-destructuring) syntax to match on constructors defined in a specific poly variant type:
-->
è¿˜æœ‰ä¸€äº›ç‰¹æ®Šçš„[æ¨¡å¼åŒ¹é…](./pattern-matching-destructuring)è¯­æ³•ï¼Œç”¨äºåŒ¹é…æŸä¸ªç‰¹å®šçš„å¤šæ€å˜ä½“ç±»å‹ä¸­å®šä¹‰çš„æ„é€ å™¨ã€‚

<CodeTab labels={["ReScript", "JS Output"]}>

```res
// ç»­å‰ä¸€ä¸ªä¾‹å­ã€‚..

switch myColor {
| #...blue => Js.log("This blue-ish")
| #...red => Js.log("This red-ish")
| other => Js.log2("Other color than red and blue: ", other)
}
```

```js
var other = myColor;

if (other === "Neon" || other === "Navy" || other === "Sapphire") {
  console.log("This is blue-ish");
} else if (other === "Rust" || other === "Ruby" || other === "Redwood") {
  console.log("This is red-ish");
} else {
  console.log("Other color than red and blue: ", other);
}
```

</CodeTab>

<!-- 
This is a shorter version of:
-->

è¿™æ˜¯ä»¥ä¸‹ä»£ç ç‰‡æ®µçš„ç®€å†™ç‰ˆæœ¬ï¼š

```res
switch myColor {
| #Sapphire | #Neon | #Navy => Js.log("This is blue-ish")
| #Ruby | #Redwood | #Rust => Js.log("This is red-ish")
| other => Js.log2("Other color than red and blue: ", other)
}
```
<!-- 
## Structural Sharing 
-->
## ç»“æ„åŒ–å…±äº«
<!-- 
Since poly variants value don't have a source of truth for their type, you can write such code:
-->
å› ä¸ºå¤šæ€å˜ä½“çš„å€¼æ²¡æœ‰ä¸€ä¸ªä¸ä¹‹å…³è”çš„çœŸæ­£çš„ç±»å‹ï¼Œæ‰€ä»¥ä½ å¯ä»¥å†™ä¸‹åƒè¿™æ ·çš„ä»£ç ï¼š

<CodeTab labels={["ReScript", "JS Output"]}>

```res
type preferredColors = [#white | #blue]

let myColor: preferredColors = #blue

let displayColor = v => {
  switch v {
  | #red => "Hello red"
  | #green => "Hello green"
  | #white => "Hey white!"
  | #blue => "Hey blue!"
  }
}

Js.log(displayColor(myColor))
```

```js
var myColor = "blue";

function displayColor(v) {
  if (v === "white") {
    return "Hey white!";
  } else if (v === "red") {
    return "Hello red";
  } else if (v === "green") {
    return "Hello green";
  } else {
    return "Hey blue!";
  }
}

console.log(displayColor("blue"));
```

</CodeTab>

<!-- 
With a regular variant, the line `displayColor(myColor)` would fail, since it'd complain that the type of `myColor` doesn't match the type of `v`. No problem with poly variant.
-->

å¦‚æœä½¿ç”¨å¸¸è§„çš„å˜ä½“ï¼Œåœ¨`displayColor(myColor)`è¿™ä¸€è¡Œå°±ä¼šæŠ¥é”™ï¼Œç±»å‹ç³»ç»Ÿä¼šæŠ±æ€¨`myColor`çš„ç±»å‹å’Œ`v`çš„ç±»å‹ä¸åŒ¹é…ã€‚ä½†è¿™åœ¨å¤šæ€å˜ä½“ä¸­æ˜¯å…è®¸çš„ã€‚
<!-- 
## JavaScript Output 
-->
## JavaScriptç¼–è¯‘ç»“æœ
<!-- 
Poly variants are great for JavaScript interop! You can share their values to JS code, or model incoming JS values as poly variants.
-->
å¤šæ€å˜ä½“ä¸º JavaScript äº’æ“ä½œæ˜¯ååˆ†æ–¹ä¾¿çš„! ä½ å¯ä»¥å’Œ JS ä»£ç å…±äº«å®ƒä»¬çš„å€¼ï¼Œæˆ–è€…å°†ä¼ å…¥çš„ JS å€¼å½“ä½œå¤šæ€å˜ä½“ã€‚
<!-- 
- `#red` and `#"I am red ğŸ˜ƒ"` compile to JavaScipt `"red"` and `"I am red ğŸ˜ƒ"`.
- `#1` compiles to JavaScript `1`.
- Poly variant constructor with 1 argument, like `Instagram("Jenny")` compile to a straightforward `{NAME: "Instagram", VAL: "Jenny"}`. 2 or more arguments like `#Facebook("Josh", 26)` compile to a similar object, but with `VAL` being an array of the arguments.
-->
- `#red` å’Œ `#"I am red ğŸ˜ƒ"` ä¼šç¼–è¯‘æˆ JavaScript çš„`"red"` å’Œ `"I am red ğŸ˜ƒ"`. 
- `#1`ç¼–è¯‘JavaScript`1`.
- æœ‰ä¸€ä¸ªå‚æ•°çš„å¤šæ€å˜ä½“æ„é€ å™¨ï¼Œåƒ`Instagram("Jenny")`ä¼šç›´æ¥ç¼–è¯‘ä¸º`{NAME: "Instagram", VAL: "Jenny"}`, 2ä¸ªæˆ–è€…æ›´å¤šçš„å‚æ•°çš„æ„é€ å™¨åƒ`#Facebook("Josh", 26)`ä¼šç¼–è¯‘æˆä¸€ä¸ªç›¸ä¼¼çš„å¯¹è±¡ï¼Œä½†æ˜¯æœ‰`VAL`å±æ€§æ¥è¡¨ç¤ºæ„é€ å™¨å‚æ•°ç»„æˆçš„æ•°ç»„ã€‚

<!-- 
### Bind to Functions 
-->

### ç»‘å®šåˆ°å‡½æ•°
<!-- 
For example, let's assume we want to bind to `Intl.NumberFormat` and want to make sure that our users only pass valid locales, we could define an external binding like this:
-->
ä¾‹å¦‚ï¼Œå‡è®¾æˆ‘ä»¬æƒ³ç»‘å®šåˆ°`Intl.NumberFormat`, å¹¶æƒ³ç¡®ä¿æˆ‘ä»¬çš„ç”¨æˆ·åªä¼ é€’æœ‰æ•ˆçš„locale, æˆ‘ä»¬å¯ä»¥è¿™æ ·å®šä¹‰ä¸€ä¸ªå¤–éƒ¨ç»‘å®šã€‚

<CodeTab labels={["ReScript", "JS Output"]}>

```res
type t

@scope("Intl") @val
external makeNumberFormat: ([#"de-DE" | #"en-GB" | #"en-US"]) => t = "NumberFormat"

let intl = makeNumberFormat(#"de-DE")
```

```js
var intl = Intl.NumberFormat("de-DE");
```

</CodeTab>

<!-- 
The JS output is identical to handwritten JS, but we also get to enjoy type errors if we accidentally write `makeNumberFormat(#"de-DR")`.
-->
JSè¾“å‡ºä¸æ‰‹å†™ JS ç›¸åŒï¼Œä½†å¦‚æœæˆ‘ä»¬ä¸å°å¿ƒå†™äº†`makeNumberFormat(#"de-DR")`, æˆ‘ä»¬ä¹Ÿèƒ½å¾—åˆ°ç±»å‹é”™è¯¯ã€‚

More advanced usage examples for poly variant interop can be found in [Bind to JS Function](bind-to-js-function#constrain-arguments-better).

å…³äºå¤šæ€å˜ä½“äº’æ“ä½œç”¨æ³•çš„æ›´é«˜é˜¶çš„ä¾‹å­å¯ä»¥çœ‹[ç»‘å®šåˆ° JS å‡½æ•°](bind-to-js-function#constrain-arguments-better)ç« èŠ‚ã€‚
<!-- 
### Bind to String Enums 
-->
### ç»‘å®šåˆ°æšä¸¾å­—ç¬¦ä¸²
<!-- 
Let's assume we have a TypeScript module that expresses following enum export:
-->
å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ª export å¦‚ä¸‹çš„æšä¸¾å€¼çš„TypeScriptæ¨¡å—ï¼š

```js
// direction.js
enum Direction {
  Up = "UP",
  Down = "DOWN",
  Left = "LEFT",
  Right = "RIGHT",
}

export const myDirection = Direction.Up
```
<!-- 
For this particular example, we can also inline poly variant type definitions to design the type for the imported `myDirection` value:
-->
å¯¹äºè¿™ä¸ªç‰¹æ®Šçš„ä¾‹å­ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å†…è”å¤šæ€å˜ä½“ç±»å‹çš„å®šä¹‰æ¥è®¾è®¡å¯¼å…¥çš„`myDirection'å€¼çš„ç±»å‹ã€‚

<CodeTab labels={["ReScript", "JS Output"]}>

```res
type direction = [ #UP | #DOWN | #LEFT | #RIGHT ]
@module("./direction.js") external myDirection: direction = "myDirection"
```

```js
var DirectionJs = require("./direction.js");

var myDirection = DirectionJs.myDirection;
```

</CodeTab>

<!-- 
Again: since we were using poly variants, the JS Output is practically zero-cost and doesn't add any extra code!
-->
å†æ¬¡æé†’ï¼šå› ä¸ºæˆ‘ä»¬æ­£åœ¨ç”¨å¤šæ€å˜ä½“ï¼Œä» JS çš„ç¼–è¯‘è¾“å‡ºçš„è§’åº¦æ¥è¯´æ˜¯é›¶å¼€é”€çš„å¹¶ä¸”ä¸ä¼šå¼•å…¥é¢å¤–ä»£ç ã€‚
<!-- 
## Extra Constraints on Types
-->
## é¢å¤–çš„ç±»å‹çº¦æŸ
<!-- 
The previous poly variant type annotations we've looked at are the regular "closed" kind. However, there's a way to express "I want at least these constructors" (lower bound) and "I want at most these constructors" (upper bound):
-->
ä¹‹å‰æˆ‘ä»¬çœ‹è¿‡çš„å¸¸è§„å˜ä½“ç±»å‹çš„ç±»å‹ç­¾åæ˜¯"å°é—­"çš„ã€‚ç„¶è€Œï¼Œæœ‰ä¸€ç§æ–¹å¼å¯ä»¥è¡¨è¾¾"æˆ‘æƒ³è‡³å°‘åŒ…å«è¿™äº›æ„é€ å™¨"(ä¸‹ç•Œ)å’Œ"æˆ‘æƒ³æœ€å¤šåŒ…å«è¿™äº›æ„é€ å™¨"(ä¸Šå±Š).

```res
// Only #Red allowed. Closed.
// åªå…è®¸ #Red æ„é€ å™¨ï¼Œå¹¶ä¸”æ˜¯å°é—­çš„
let basic: [#Red] = #Red

// May contain #Red, or any other value. Open
// here, foreground will actually be inferred as [> #Red | #Green]
// å¯ä»¥åŒ…å« #Red, æˆ–è€…å…¶ä»–å€¼ï¼Œå¹¶ä¸”æ˜¯å¼€æ”¾çš„ã€‚
// è¿™é‡Œï¼Œforegroundä¼šè¢«æ¨å¯¼ä¸º [> #Red | #Green] ç±»å‹
let foreground: [> #Red] = #Green

// The value must be, at most, one of #Red or #Blue
// Only #Red and #Blue are valid values
// è¿™é‡Œï¼Œå€¼åªèƒ½æ˜¯ #Red å’Œ #Blue ä¹‹ä¸€
let background: [< #Red | #Blue] = #Red
```
<!-- 
**Note:** We added this info for educational purposes. In most cases you will not want to use any of this stuff, since it makes your APIs pretty unreadable / hard to use.
-->
**æ³¨æ„ï¼š** æˆ‘ä»¬æˆ‘ä»¬è¡¥å……è¿™äº›ç±»å‹ä¸»è¦æ˜¯ä¸ºäº†æ•™å­¦ç›®çš„ï¼Œå¤§å¤šæ•°æƒ…å†µä½ ä¸éœ€è¦ç”¨åˆ°è¿™äº›ï¼Œå› ä¸ºè¿™ä¼šè®©ä½ çš„ API å˜å¾—éš¾ä»¥é˜…è¯»æˆ–éš¾ä»¥ä½¿ç”¨ã€‚
<!-- 
### Closed `[` 
-->
### å°é—­å®šä¹‰ `[`
<!-- 
This is the simplest poly variant definition, and also the most practical one. Like a common variant type, this one defines an exact set of constructors.
-->
è¿™æ˜¯ä¸ä»…æ˜¯æœ€ç®€å•çš„å¤šæ€å˜ä½“çš„å®šä¹‰ï¼Œè€Œä¸”æ˜¯æœ€å®ç”¨çš„ã€‚å’Œæ™®é€šçš„å˜ä½“ç±»å‹ä¸€æ ·ï¼Œè¿™ä¸ªç±»å‹å®šä¹‰äº†ç²¾ç¡®çš„æ„é€ å‡½æ•°é›†åˆã€‚

```res
type rgb = [ #Red | #Green | #Blue ]

let color: rgb = #Green
```
<!-- 
In the example above, `color` will only allow one of the three constructors that are defined in the `rgb` type. This is usually the way how poly variants should be defined.
-->
åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œ`color`çš„å€¼åªå…è®¸`rgb`ç±»å‹ä¸­å®šä¹‰çš„ä¸‰ä¸ªæ„é€ å™¨ä¹‹ä¸€ï¼Œè¿™æ˜¯å¤šæ€å˜ä½“æœ€å¸¸ç”¨çš„å®šä¹‰ã€‚
<!-- 
In case you want to define a type that is extensible, you'll need to use the lower / upper bound syntax.
-->
ä¸ºäº†ä»¥é˜²ä¸‡ä¸€ä½ æƒ³è¦å®šä¹‰å¯æ‰©å±•çš„ç±»å‹ï¼Œä½ å¯èƒ½éœ€è¦ç”¨åˆ°ä¸‹ç•Œ/ä¸Šå±Šè¯­æ³•ã€‚

<!-- 
### Lower Bound `[>` 
-->

### ä¸‹ç•Œå®šä¹‰ `[>`
<!-- 
A lower bound defines the minimum set of constructors a poly variant type is aware of. It is also considered an "open poly variant type", because it doesn't restrict any additional values.
-->
 
ä¸‹ç•Œå®šä¹‰ï¼Œå®šä¹‰äº†ä¸€ä¸ªå¤šæ€å˜ä½“ç±»å‹æ‰€çŸ¥é“çš„æœ€å°æ„é€ å‡½æ•°é›†åˆã€‚å®ƒä¹Ÿè¢«è®¤ä¸ºæ˜¯ä¸€ä¸ª "å¼€æ”¾çš„èšå˜ä½“ç±»å‹", å› ä¸ºå®ƒä¸é™åˆ¶ä»»ä½•é¢å¤–çš„å€¼ã€‚
<!-- 
Here is an example on how to make a minimum set of `basicBlueTones` extensible for a new `color` type:
-->
ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­ï¼Œå±•ç¤ºäº†å¦‚ä½•ä½¿ä¸€ç»„æœ€å°çš„ "basicBlueTones "å¯æ‰©å±•ä¸ºä¸€ä¸ªæ–°çš„ "color "ç±»å‹ã€‚

```res
type basicBlueTone<'a> = [> #Blue | #DeepBlue | #LightBlue ] as 'a
type color = basicBlueTone<[#Blue | #DeepBlue | #LightBlue | #Purple]>

let color: color = #Purple

// This will fail due to missing minimum constructors:
type notWorking = basicBlueTone<[#Purple]>
```
<!-- 
Here, the compiler will enforce the user to define `#Blue | #DeepBlue | #LightBlue` as the minimum set of constructors when trying to extend `basicBlueTone<'a>`.
-->
è¿™é‡Œç¼–è¯‘å™¨ä¼šå¼ºåˆ¶ç”¨æˆ·åœ¨æ‰©å±•`basicBlueTone<'a>`çš„æ—¶å€™åŒ…å«æœ€å°çš„æ„é€ å™¨é›†åˆ`#Blue | #DeepBlue | #LightBlue`.
<!-- 
**Note:** Since we want to define an extensible poly variant, we need to provide a type placeholder `<'a>`, and also add `as 'a` after the poly variant declaration, which essentially means: "Given type `'a` is constraint to the minimum set of constructors (`#Blue | #DeepBlue | #LightBlue`) defined in `basicBlueTone`".
-->
**æ³¨æ„ï¼š** å› ä¸ºæˆ‘ä»¬æƒ³è¦å®šä¹‰å¯æ‰©å±•çš„å¤šæ€å˜ä½“ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªç±»å‹å ä½ç¬¦`<'a>`, å¹¶ä¸”éœ€è¦ä¸€ä¸ªåœ¨ç±»å‹å£°æ˜åé¢åŠ ä¸Š `as 'a` , åŸºæœ¬ä¸Šæ˜¯åœ¨è¯´ï¼š"ç»™æˆ‘çš„ç±»å‹`'a`æ˜¯è¦æ»¡è¶³æœ€å°çš„æ„é€ å™¨é›†åˆ(`#Blue | #DeepBlue | #LightBlue`)çš„çº¦æŸï¼Œè¿™äº›çº¦æŸå®šä¹‰åœ¨`basicBlueTone`ä¸­".

### Upper Bound `[<` | ä¸Šç•Œå®šä¹‰ `[<`
<!-- 
The upper bound works in the opposite way than a lower bound: the extending type may only use constructors that are stated in the upper bound constraint.
-->
ä¸Šç•Œå®šä¹‰çš„å·¥ä½œæ–¹å¼å’Œä¸‹ç•Œå®šä¹‰ç›¸åï¼šæ‰©å±•çš„ç±»å‹åªèƒ½ä½¿ç”¨ä¸Šç•Œçº¦æŸä¸­çš„æ„é€ å™¨ã€‚
<!-- 
Here another example, but with red colors:
-->
è¿™æ˜¯å¦ä¸€ä¸ªä¾‹å­ï¼š

```res
type validRed<'a> = [< #Fire | #Crimson | #Ash] as 'a
type myReds = validRed<[#Ash]>

// This will fail due to unlisted constructor not defined by the lower bound
type notWorking = validRed<[#Purple]>
```
<!-- 
## Coercion 
-->

## å¼ºåˆ¶ç±»å‹è½¬æ¢
<!-- 
You can convert a poly variant to a `string` or `int` at no cost:
-->

ä½ å¯ä»¥å°†ä¸€ä¸ªå¤šæ€å˜ä½“ç±»å‹çš„å€¼æ— æˆæœ¬çš„è½¬æ¢åˆ°è½¬æ¢åˆ°`string`æˆ–`int`ç±»å‹ï¼š

<CodeTab labels={["ReScript", "JS Output"]}>

```res
type company = [#Apple | #Facebook]
let theCompany: company = #Apple

let message = "Hello " ++ (theCompany :> string)
```

```js
var theCompany = "Apple";
var message = "Hello " + theCompany;
```

</CodeTab>

<!-- 
**Note**: for the coercion to work, the poly variant type needs to be closed; you'd need to annotate it, since otherwise, `theCompany` would be inferred as `[> #Apple]`.
-->

**æ³¨æ„**: ä¸ºäº†è®©å¼ºåˆ¶è½¬æ¢æ­£å¸¸å·¥ä½œï¼Œå¤šæ€å˜ä½“ç±»å‹éœ€è¦æ—¶å°é—­çš„; ä½ éœ€è¦æ˜¾å¼çš„æ ‡æ³¨å®ƒï¼Œå¦åˆ™`theCompany`ä¼šè¢«æ¨å¯¼ä¸º`[> #Apple]`ç±»å‹ã€‚

<!-- 
## Tips & Tricks 
-->

## æŠ€å·§å’Œè¯€çª
<!-- 
### Variant vs Polymorphic Variant 
-->

### å˜ä½“ vs å¤šæ€å˜ä½“
<!-- 
One might think that polymorphic variants are superior to regular [variants](./variant). As always, there are trade-offs:
-->

æœ‰äººå¯èƒ½ä¼šè§‰å¾—å¤šæ€å˜ä½“æ¯”[å¸¸è§„å˜ä½“](./variant)æ›´å¼ºå¤§ã€‚å¦‚å¾€å¸¸ä¸€æ ·ï¼Œè¿™æ¶‰åŠåˆ°åˆ©å¼Šæƒè¡¡ï¼š

<!-- - Due to their "structural" nature, poly variant's type errors might be more confusing. If you accidentally write `#blur` instead of `#blue`, ReScript will still error but can't indicate the correct source as easily. Regular variants' source of truth is the type definition, so the error can't go wrong.
- It's also harder to refactor poly variants. Consider this:
  ```res
  let myFruit = #Apple
  let mySecondFruit = #Apple
  let myCompany = #Apple
  ```
  Refactoring the first one to `#Orange` doesn't mean we should refactor the third one. Therefore, the editor plugin can't touch the second one either. Regular variant doesn't have such problem, as these 2 values presumably come from different variant type definitions.

- You might lose some nice pattern match checks from the compiler:
  ```res
  let myColor = #red

  switch myColor {
  | #red => Js.log("Hello red!")
  | #blue => Js.log("Hello blue!")
  }
  ```
  Because there's no poly variant definition, it's hard to know whether the `#blue` case can be safely removed.
-->
- ç”±äºå¤šæ€å˜ä½“çš„"ç»“æ„åŒ–"æœ¬è´¨ï¼Œå¤šæ€å˜ä½“äº§ç”Ÿçš„ç±»å‹é”™è¯¯å¯èƒ½æ›´ä»¤äººå›°æƒ‘ã€‚å¦‚æœä½ ä¸å°å¿ƒå†™äº†`#blur`è€Œä¸æ˜¯`#blue`, ReScript ä»ç„¶ä¼šå‡ºé”™ï¼Œä½†æ— æ³•è½»æ˜“æŒ‡å‡ºæ­£ç¡®çš„æ¥æºã€‚æ™®é€šå˜ä½“çš„æœ¬è´¨æ¥æºæ˜¯ç±»å‹å®šä¹‰ï¼Œæ‰€ä»¥æŠ¥é”™ä¸ä¼šæŒ‡å‘é”™è¯¯çš„åœ°æ–¹ã€‚
- å¯¹å¤šæ€å˜ä½“è¿›è¡Œé‡æ„æ›´éš¾ã€‚çœ‹çœ‹è¿™ä¸ªï¼š
  ```res
  let myFruit = #Apple
  let mySecondFruit = #Apple
  let myCompany = #Apple
  ```
  æŠŠç¬¬ä¸€ä¸ªå®šä¹‰é‡æ„æˆ `#Orange` ä¸ä¸€å®šæ„å‘³ç€æˆ‘ä»¬ä¹Ÿåº”è¯¥é‡æ„ç¬¬ä¸‰ä¸ªã€‚åŒæ ·çš„é“ç†ï¼Œç¼–è¾‘å™¨æ’ä»¶ä¹Ÿä¸ä¼šåŠ¨ç¬¬äºŒä¸ªã€‚å¸¸è§„çš„å˜ä½“åˆ™æ²¡æœ‰è¿™æ ·çš„é—®é¢˜ï¼Œå› ä¸ºè¿™äº›å˜ä½“ä¼šæ¥è‡ªäºä¸åŒçš„ç±»å‹å®šä¹‰ã€‚
- ä½ å¯èƒ½ä¼šå¤±å»ä¸€äº›æ¥è‡ªç¼–è¯‘å™¨çš„å¾ˆæ£’çš„æ¨¡å¼åŒ¹é…æ£€æŸ¥ï¼š
  ```res
  let myColor = #red

  switch myColor {
  | #red => Js.log("Hello red!")
  | #blue => Js.log("Hello blue!")
  }
  ```
  å› ä¸ºæ²¡æœ‰å¤šæ€å˜ä½“çš„å®šä¹‰ï¼Œå¾ˆéš¾çŸ¥é“æ˜¯å¦å¯ä»¥å®‰å…¨çš„åˆ é™¤ `#blue` åˆ†æ”¯ã€‚

<!-- 
In most scenarios, we'd recommend to use regular variants over polymorphic variants, especially when you are writing plain ReScript code. In case you want to write zero-cost interop bindings or generate clean JS output, poly variants are oftentimes a better option.
-->
åœ¨å¤§å¤šæ•°ä½¿ç”¨åœºæ™¯ä¸‹ï¼Œæˆ‘ä»¬ä¼šæ¨èä½¿ç”¨å¸¸è§„å˜ä½“ä¼˜å…ˆäºå¤šæ€å˜ä½“ï¼Œå°¤å…¶æ—¶å½“ä½ åœ¨å†™çº¯ ReScript ä»£ç çš„æ—¶å€™ã€‚åœ¨ä½ æƒ³è¦å†™é›¶æˆæœ¬äº’æ“ä½œçš„ç»‘å®šæˆ–è€…ç”Ÿæˆç®€æ´çš„ JS ä»£ç ï¼Œå¤šæ€å˜ä½“å¸¸å¸¸ä¼šæ˜¯ä¸€ä¸ªæ›´å¥½çš„é€‰æ‹©ã€‚
